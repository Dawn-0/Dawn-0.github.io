<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++_primer_V5 学习笔记-第一章</title>
    <url>/2020/07/13/c-primer-1/</url>
    <content><![CDATA[<h3 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a>第1章 开始</h3><p>本章介绍c++的大部分基础内容：类型、变量、表达式、语句及函数。并介绍如何编译及运行程序。</p>
<a id="more"></a>

<h4 id="编写一个简单的C-程序"><a href="#编写一个简单的C-程序" class="headerlink" title="编写一个简单的C++程序"></a>编写一个简单的C++程序</h4><ul>
<li>函数定义<ul>
<li>返回类型</li>
<li>函数名</li>
<li>形参列表（允许为空</li>
<li>函数体</li>
</ul>
</li>
<li>main函数的返回类型必须为int。</li>
<li><strong>内置类型（built-in-type）：语言自身定义的类型</strong></li>
<li>函数体中使用return结束函数的执行，return返回的值与函数的返回类型相容</li>
<li>大多数系统中，main的返回值被用来指示状态，返回0表示成功，非0值常用于指出错误类型</li>
</ul>
<h5 id="编译、运行程序"><a href="#编译、运行程序" class="headerlink" title="编译、运行程序"></a>编译、运行程序</h5><ul>
<li><p>集成开发环境IDE：将编译器与其他程序创建和分析工具包装在一起</p>
</li>
<li><p>源文件：程序文件常被称为 <strong>源文件（source file</strong></p>
</li>
<li><p>源文件名字以后缀结尾：.cc .cxx .cpp .cp .C    …</p>
</li>
<li><p>命令行运行编译器</p>
<ul>
<li><p>CC是编译器程序的名字 main程序在prog1.cc中</p>
</li>
<li><p>编译器生成一个可执行文件 windows为prog1.exe unix后缀为<strong>a.out</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ CC prog1.cc</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>windows运行可执行文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ prog1</span><br><span class="line">$ .\prog1</span><br></pre></td></tr></table></figure>
</li>
<li><p>unix运行可执行文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ a.out</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>在unix和windows中，执行完程序后都可以使用 <strong>echo命令获得返回值</strong> </p>
<ul>
<li><p>unix 获得状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
</li>
<li><p>windows 查看状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">%ERRORLEVEL%</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>GNU编译器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ g++ -o prog1 prog1.cc</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-o prog1是编译器参数 指定可执行文件的文件名</p>
</li>
<li><p>该指令生成可执行文件 windows后缀为.exe UNIX无后缀</p>
</li>
<li><p>若省略 -o prog1参数 windows生成a.exe UNIX生成a.out</p>
</li>
</ul>
</li>
<li><p>微软Visual Studio编译器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">me</span>\<span class="title">Programs</span>&gt; <span class="title">c1</span> /<span class="title">EHsc</span> <span class="title">prog1.cpp</span></span></span><br></pre></td></tr></table></figure>

<p>c1调用编译器   /EHsc是编译器选项(打开标准异常处理</p>
<ul>
<li>生成可执行文件prog1.exe</li>
</ul>
</li>
<li><p>编译器可以对有问题的程序结构发出警告 打开选项</p>
<ul>
<li>GNU使用-Wall VS编译器使用/W4</li>
</ul>
</li>
</ul>
<h4 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h4><ul>
<li><p>C++语言使用 <strong>标准库</strong> 提供IO机制等</p>
</li>
<li><p>iostream库 </p>
<ul>
<li>包含istream和ostream 表示输入流和输出流</li>
<li>一个流是一个字符序列，从IO设备读出/写入IO设备</li>
</ul>
</li>
<li><p>标准输入输出对象</p>
<ul>
<li>cin 标准输入 istream类型</li>
<li>cout 标准输出 ostream类型</li>
<li>cerr 标准错误 输出警告和错误信息</li>
<li>clog 输出程序运行时的一般性信息</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用iostream库，iostream指出了一个 <strong>头文件</strong></li>
</ul>
</li>
<li><p>表达式：由运算对象和运算符组成</p>
</li>
<li><p>输出运算符&lt;&lt;   ： 接受两个运算对象 左侧为ostream对象 右侧是要打印的值 将给定值写入给定的ostream对象中</p>
</li>
<li><p>操纵符 std::endl 写入的效果是结束当前行 <strong>将与设备关联的缓冲区内容刷到设备中</strong></p>
<ul>
<li>缓冲刷新操作保证 到目前为止程序产生的输出 <strong>真正写入输出流中</strong> 而非内存中等待写入</li>
<li>调试时的打印语句应该保证一直刷新流，防止崩溃时输出还留在缓冲区 难以判断出错位置</li>
</ul>
</li>
<li><p>前缀std:: 表示定义在名为std的命名空间中   ::是作用域运算符</p>
</li>
<li><p>标准库定义的所有名字都在命名空间std中</p>
</li>
<li><p>输入运算符&gt;&gt; 左侧为istream对象 右侧为存入的对象</p>
</li>
<li><p>标准库定义了不同版本的运算符 处理不同类型的运算对象</p>
</li>
</ul>
<h4 id="注释comments-简介"><a href="#注释comments-简介" class="headerlink" title="注释comments 简介"></a>注释comments 简介</h4><ul>
<li><p>两种注释</p>
<ul>
<li>单行注释：双斜线开始，换行符结束。可以包含任何文本，包括额外的双斜线。</li>
<li>界定符对注释：以 /* 开始，以 */ 结束。可以包含除了 */ 以外的任何内容，包括换行符、</li>
</ul>
</li>
<li><p>常使用的风格：注释内的每行都以一个星号开头</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abc</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * aaaaa</span></span><br><span class="line"><span class="comment"> * aaaaa</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释界定符不能嵌套，最好的注释方式是用单行注释方式注释掉代码段的每一行。</p>
</li>
</ul>
<h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><ul>
<li><p>while语句</p>
</li>
<li><p>for语句</p>
</li>
<li><p>读取数量不定的输入数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,value=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;value)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>while使用istream对象作为条件，检测流的状态。若流是有效的，检测成功；遇到文件结束符（end-of-file）或无效输入。istream对象无效，检测条件为假。</li>
</ul>
</li>
<li><p>文件结束符：windows ctrl+Z 再enter或return UNIX输入ctrl+D</p>
</li>
<li><p>编译器：检查形式上的错误，错误信息包含行号和简短描述</p>
<ul>
<li>语法错误</li>
<li>类型错误</li>
<li>声明错误</li>
</ul>
</li>
<li><p>按照报告顺序逐个修正错误，修正后立即重新编译。</p>
</li>
<li><p>if语句</p>
</li>
<li><p>左花括号必须是形参列表后的第一个非空、非注释的字符</p>
</li>
</ul>
<h4 id="类简介（class"><a href="#类简介（class" class="headerlink" title="类简介（class"></a>类简介（class</h4><ul>
<li><p>定义类来定义自己的数据结构</p>
</li>
<li><p>在头文件中定义（后缀.h .H .hxx .hpp …)</p>
</li>
<li><p>类的作者决定了类 类型对象上可以使用的所有操作</p>
</li>
<li><p>包含标准库的头文件 使用尖括号&lt;&gt; ；不属于标准库的头文件 使用双引号””</p>
</li>
<li><p>文件重定向：将标准输入和标准输出与命名文件关联起来</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>

<p>addItems是编译后的可执行文件，则上述命令会从当前目录的 一个名为infile的文件读取数据，并将结果写入一个名为outfile的文件中</p>
</li>
<li><p>成员函数（方法：定义为类的一部分的函数</p>
</li>
<li><p>点运算符(.)：指定类的成员</p>
</li>
<li><p>调用运算符（ () ）：调用一个函数，括号内放置实参（可能没有</p>
</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>缓冲区（buffer：IO设施通常将输入或输出数据保存在一个缓冲区中，读写缓冲区的动作与程序无关。<ul>
<li>可以显式刷新输出缓冲，强制将缓冲区的数据写入输出设备</li>
<li>读cin 或 程序非正常终止 时，会刷新cout</li>
</ul>
</li>
<li>Cerr：ostream对象，写到cerr的数据默认不缓冲。常用于输出错误信息或不属于程序正常逻辑的输出内容。</li>
<li>clog：ostream对象。写到clog的数据默认缓冲。报告程序的执行信息，存入一个日志文件中。</li>
<li>main函数： <strong>每个程序有且只有一个命名为main的函数</strong></li>
<li>命名空间：将库定义的名字放在一个单一位置的机制。避免名字冲突</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第二章</title>
    <url>/2020/07/13/c-primer-2/</url>
    <content><![CDATA[<h3 id="第I部分-C-基础-（第2章-第7章）"><a href="#第I部分-C-基础-（第2章-第7章）" class="headerlink" title="第I部分 C++基础 （第2章-第7章）"></a>第I部分 C++基础 （第2章-第7章）</h3><h3 id="第2章-变量和基本类型"><a href="#第2章-变量和基本类型" class="headerlink" title="第2章 变量和基本类型"></a>第2章 变量和基本类型</h3><p>本章主要讲述内置类型，以及c++如何支持更复杂的数据类型。</p>
<a id="more"></a>

<ul>
<li>任何编程语言都具备一组公共的语法特征。最基本的特征包括：<ul>
<li>整形、字符型等<strong>内置类型</strong></li>
<li><strong>变量</strong>，为对象命名</li>
<li><strong>表达式和语句</strong>，操纵上述类型的具体值</li>
<li><strong>控制结构</strong>，控制语句执行</li>
<li><strong>函数</strong>，定义可随时调用的计算单元</li>
</ul>
</li>
<li>大多数编程语言通过两种方式进一步补充基本特征：<ul>
<li>程序员自定义数据类型</li>
<li>将有用的功能封装成库函数</li>
</ul>
</li>
<li>C++的对象类型决定对它进行的操作。</li>
<li>C++是一种静态数据类型语言，编译时进行类型检查。编译器要知道每个变量对应的数据类型。</li>
<li>简单的编程语言，强大的<strong>数据结构自定义</strong></li>
<li>最重要的语法特征是 <strong>类class</strong> ，允许新类型包含数据和函数成员</li>
</ul>
<h4 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h4><ul>
<li><p>包括<strong>算术类型</strong>和<strong>空类型</strong></p>
</li>
<li><p>算术类型</p>
<ul>
<li>整型：包括字符和布尔类型</li>
<li>浮点型</li>
</ul>
</li>
<li><p>一个char型的大小和一个机器字节一样（8bit=1byte）</p>
</li>
<li><p>short16–int16–long32–long long64</p>
</li>
<li><p><strong>内置类型的机器实现</strong></p>
<ul>
<li>计算机以比特序列存储数据。可寻址的最小内存块为 <strong>字节byte</strong>，存储的基本单元称为 <strong>字word</strong> 。1word=4 or 8 byte = 32 or 64 bit</li>
<li>一个字节对应一个地址</li>
<li>一个字或字节的首位（bit）地址即表示这个字或字节的地址</li>
<li>如果一个对象类型是32位，计算机一个字有4个字节，那么用4个字节/1个字存储这个对象</li>
</ul>
</li>
<li><p>float单精度 6位有效数字 32位–double双精度 10位有效数字 64位–long double扩展精度 10位有效数字 96or128位</p>
</li>
<li><p>带符号和无符号类型</p>
<ul>
<li>带符号：正数 负数 0 int short long longlong。标识范围内正值和负值的量应该平衡。如8bit的char为-128-127</li>
<li>无符号：大于等于0的值 添加unsigned即无符号 如unsigned long。所有比特都用来存储值。</li>
<li>字符型分为三种：char 、signed char、unsigned char。但表现形式仍为两种：带符号、无符号。char表现为二者之一，由编译器决定</li>
</ul>
</li>
<li><p>如何选择类型</p>
<ul>
<li>数值不可能为负–使用无符号</li>
<li>整数运算用int，若超过范围使用longlong</li>
<li>算术表达式中不用char或bool</li>
<li>浮点数运算用double</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li>赋给无符号类型超出范围的值：初始值 对 无符号表示数值的总数 取模的余数，如下c=255.</li>
<li>赋给带符号类型超出范围的值：结果是未定义的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b=<span class="number">42</span>;					<span class="comment">//b=true</span></span><br><span class="line"><span class="keyword">int</span> i=b;  					<span class="comment">//i=1</span></span><br><span class="line">i=<span class="number">3.14</span>;						<span class="comment">//i=3</span></span><br><span class="line"><span class="keyword">double</span> pi=i;				<span class="comment">//pi=3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">-1</span>;			<span class="comment">//c=255  0-255区间 -1对256取模得到的余数（取模操作结果为正数） （-1 mod 256=（-1+256）mod 256=255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2=<span class="number">256</span>;			<span class="comment">//c2为未定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>避免无法预知和依赖于实现环境的行为</p>
<ul>
<li>无法预知：编译器无法检测</li>
<li>依赖于实现环境：如把int的尺寸看做确定不变的尺寸值，则程序 <strong>不可移植</strong></li>
</ul>
</li>
<li><p>bool值在算术表达式中非0即1，因此不宜在算术表达式中用bool。</p>
</li>
<li><p>含有无符号类型的表达式–例1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">-42</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; i + i &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//输出-84  （-42）+（-42）=-84</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若int占32位，输出4294967264，相加前把i（-42）转换为无符号数</span></span><br><span class="line"><span class="comment">//（-42）mod（2^32）=（2^32-42）mod（2^32）=2^32-42=4294967296-42=4294967254,也就是i转换后的值</span></span><br><span class="line"><span class="comment">//计算i+u，4294967254+10=4294967264，输出结果。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u + i &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>含有无符号类型的表达式–例2</p>
<ul>
<li>从无符号数中减去一个值时，不管这个值是不是无符号数，都必须确保结果不能是负值。否则结果为取模后的值，如下。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u1=<span class="number">42</span>,u2=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u1 - u2 &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//输出32 正确</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u2 - u1 &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//正确，但输出取模后的值 4294967264  </span></span><br><span class="line"><span class="comment">//10-42=（-32），（-32）mod（2^32）=（2^32-32）mod（2^32）=（2^32-32）= 4294967264</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无符号数+循环控制</p>
<ul>
<li><p>常使用while代替for，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> u=<span class="number">10</span>;u&gt;=<span class="number">0</span>;--u)</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出0后，执行--u。此时u=-1，转换为无符号数（取模），u=4294967295，陷入死循环。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法，使用while循环，同样输出10到0，避免执行 u取0时再减1。</span></span><br><span class="line"><span class="keyword">unsigned</span> u=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">while</span>(u&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	--u;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>切忌混用带符号类型和无符号类型，带符号数会自动转换为无符号数，出现异常结果。</p>
</li>
<li><p>字面值常量：形式和值决定它的数据类型</p>
</li>
<li><p>整型字面值：类型默认为容纳其数值的 <strong>尺寸最小的类型</strong>。 <strong>short类型没有对应的字面值。</strong></p>
<ul>
<li>八进制：0开头</li>
<li>十六进制：0x或0X开头</li>
<li>十进制：正常表示。十进制字面值不会是负数，形如-42，负号并不属于字面值，仅对字面值取负值。</li>
</ul>
</li>
<li><p>浮点型字面值默认为double</p>
</li>
<li><p>char型字面值：单引号包括</p>
</li>
<li><p>字符串型字面值:双引号包括。编译器在结尾加一个空字符（‘\0’)，字面值实际长度比内容多1。</p>
<ul>
<li><p>若字符串字面值紧邻，仅由空格、缩进、换行符分隔，则为一个整体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"aaaaaa"</span></span><br><span class="line">		<span class="string">"bbbb"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出一行字符串“aaaaaabbbb”</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>转义序列：两类字符不能直接使用，需要使用转义序列。以反斜线作为开始，被当做一个字符使用</p>
<ul>
<li>不可打印字符：退格等，无可视的图符</li>
<li>有特殊含义的字符：单双引号、问号、反斜线…</li>
</ul>
</li>
<li><p>泛化转义序列：\x后加十六进制数，或\后跟1、2或3个八进制数字。数字部分表示字符对应数值。</p>
<ul>
<li>若反斜线后跟超过3个八进制数字，只有前三个与\构成转义序列</li>
<li>\x后可以跟任意个十六进制数字</li>
</ul>
</li>
<li><p>指定字面值类型</p>
<ul>
<li>添加前缀和后缀，可以改变整型、浮点型、字符型字面值的默认类型。</li>
<li>长整型建议使用大写L标记。</li>
<li>字符和字符串用前缀指定；整型和浮点型用后缀指定。</li>
</ul>
</li>
<li><p>布尔字面值：true、false</p>
</li>
<li><p>指针字面值：nullptr</p>
</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li><p>变量提供一个具名的、可供程序操作的存储空间。</p>
</li>
<li><p>变量的数据类型决定内存大小、布局方式、存储值的范围、能参与的运算。</p>
</li>
<li><p>变量定义：类型说明符+一个或多个变量名的列表。</p>
</li>
<li><p>什么是<strong>对象</strong>？</p>
<ul>
<li>一块能<strong>存储数据</strong>并具有某种<strong>类型</strong>的<strong>内存空间</strong>。</li>
</ul>
</li>
<li><p>初始化：对象在创建时获得一个特定的值。</p>
<ul>
<li><p>同一定义语句中，可以用先定义的变量值 初始化 后定义的其他变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> price=<span class="number">109.99</span>,discount=price*<span class="number">0.16</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>初始化不是赋值！</strong></p>
<ul>
<li>初始化在创建变量是赋予一个初始值</li>
<li>赋值把对象的当前值擦除，再用一个新值替代。</li>
</ul>
</li>
<li><p>列表初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//四种初始化语句</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//列表初始化</span></span><br><span class="line"><span class="keyword">int</span> a=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>若使用列表初始化，且初始值存在丢失的风险，则编译器会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;,b=&#123;ld&#125;;<span class="comment">//使用列表初始化 编译器报错：转换未执行，存在丢失信息的风险。</span></span><br><span class="line"><span class="keyword">int</span> c&#123;ld&#125;,d=ld;<span class="comment">//不使用列表初始化 通过编译：转换执行，确实丢失了部分值。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>默认初始化</p>
<ul>
<li>定义变量时未指定初值，则默认初始化，变量被赋予默认值。</li>
<li>默认值由变量类型决定，定义变量的位置也有影响。</li>
<li>定义于函数体之外的变量被初始化为0.</li>
<li>定义在函数体内部的变量不被初始化，它的值是未定义的。若访问此类值将出错。</li>
<li>每个类决定其初始化对象的方式，以及能否不经初始化就定义对象。</li>
<li>绝大多数类 无须显示初始化 来定义对象，提供一个合适的默认值。如string类（未指定初值，则生成一个空串</li>
<li>一些类要求每个对象进行显式初始化，否则报错。</li>
</ul>
</li>
<li><p>未初始化变量会引发运行时故障</p>
<ul>
<li>建议初始化每一个内置类型的变量，确保初始化后程序安全。</li>
</ul>
</li>
<li><p>分离式编译</p>
<ul>
<li>允许将程序分割成若干个文件，每个文件独立编译。</li>
</ul>
</li>
<li><p>变量的声明和定义</p>
<ul>
<li><p>声明：名字被程序所知，文件要使用别处定义的名字，必须包含对那个名字的声明。</p>
</li>
<li><p>定义：创建与名字关联的实体。为变量申请空间，可能赋初值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;	<span class="comment">//只声明i，并未定义i</span></span><br><span class="line"><span class="keyword">int</span> j;			<span class="comment">//声明i，并且定义i</span></span><br><span class="line"><span class="comment">//extern语句若包含初始值，则变成定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.1415</span>;<span class="comment">//定义pi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明+赋初始值=定义</p>
</li>
<li><p>函数体内部，若初始化一个extern标记的变量，会报错。</p>
</li>
<li><p>变量能且只能被定义一次，但可以被多次声明。</p>
</li>
</ul>
</li>
<li><p>多个文件使用同一个变量</p>
<ul>
<li>变量定义只能出现在一个文件中</li>
<li>其他用到该变量的文件要对其声明，但不能重复定义。</li>
</ul>
</li>
<li><p>静态类型：在编译阶段 检查类型（类型检查）</p>
<ul>
<li>C++是静态类型语言</li>
<li>编译器检查数据类型是否支持要执行的运算，不支持则报错，不生成可执行文件</li>
<li>使用变量前必须声明某个类型，以便编译器进行检查。</li>
</ul>
</li>
<li><p>标识符</p>
<ul>
<li>必须以字母或下划线开头</li>
<li>对大小写字母敏感</li>
<li>不能使用标准库关键字</li>
<li>不能连续出现两个下划线，也不能下划线紧连大写字母开头。</li>
<li>函数体外的标识符不能以下划线开头。</li>
</ul>
</li>
<li><p>变量命名规范</p>
<ul>
<li>一般用小写字母</li>
<li>自定义类名一般大写字母开头</li>
<li>若标识符由多个单词组成，由大写字母或下划线分割</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li><p>多数作用域用大括号分隔</p>
</li>
<li><p>同一个名字在不同的作用域中可能指向不同的实体</p>
</li>
<li><p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> val=<span class="number">1</span>;val&lt;=<span class="number">10</span>;++val)</span><br><span class="line">		sum+=val;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"Sum of 1 to 10 inclusive is"</span></span><br><span class="line">		     &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了3个名字 main、sum、val，并使用了命名空间名字std，该空间提供了两个名字cout、cin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局作用域：main。声明后在整个程序内都可使用。</p>
</li>
<li><p>块作用域：sum。声明后到函数结束为止都可使用。</p>
</li>
<li><p>名字val仅可在for循环内访问。</p>
</li>
</ul>
</li>
<li><p>在第一次使用变量时再定义它，更容易找到定义和赋初值。</p>
</li>
<li><p>嵌套的作用域 （外层作用域（内层作用域））</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> reused=<span class="number">42</span>;					<span class="comment">//全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> unique=<span class="number">0</span>;				<span class="comment">//unique拥有块作用域</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//输出全局变量reused=42</span></span><br><span class="line">	<span class="keyword">int</span> reused=<span class="number">0</span>;				<span class="comment">//定义局部变量reused，覆盖了全局变量</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//输出局部变量reused=0</span></span><br><span class="line">    <span class="comment">//使用作用域操作符 :: ，覆盖默认的作用域规则。操作符左侧为空，默认使用全局作用域中的右侧变量。</span></span><br><span class="line">    <span class="comment">//显示访问全局变量reused，输出reused=42</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;::reused&lt;&lt;<span class="built_in">endl</span>;		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要定义和全局变量同名的局部变量。</p>
</li>
</ul>
<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>基于其他类型定义的类型。</p>
<ul>
<li><p>声明语句：由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量，并指定其为 与基本数据类型相关的类型。</p>
</li>
<li><p>引用（左值引用</p>
<ul>
<li><p>引用类型 引用 另外一种类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival=<span class="number">1024</span>;		<span class="comment">//定义int型变量ival，初始化为1024</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal=ival;	<span class="comment">//定义引用类型的变量refVal，指向ival（refVal是ival的另一个名字</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;		<span class="comment">//报错：引用必须被初始化</span></span><br><span class="line">refVal=<span class="number">2</span>;			<span class="comment">//即把2赋值给了ival</span></span><br><span class="line"><span class="keyword">int</span> ii=refVal;		<span class="comment">//ii初始化为ival的值</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3=refVal;<span class="comment">//refVal3绑定到了ival上</span></span><br><span class="line"><span class="keyword">int</span> i=refVal;		<span class="comment">//i被初始化为ival的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化后，引用会和它的初始值对象一直 绑定bind 在一起。   <strong>引用必须初始化</strong></p>
</li>
<li><p>引用不是对象，它是一个已有对象的另一个名字</p>
</li>
<li><p>无法定义引用的引用，因为引用不是对象，只能定义一个对象的引用。</p>
</li>
<li><p>除了两种例外情况，引用的类型与绑定对象严格匹配。</p>
</li>
<li><p><strong>非常量引用只能绑定在对象上，不能是字面值或计算结果。</strong></p>
</li>
<li><p>定义引用后，每次使用引用都会访问它 最初绑定的那个对象。</p>
</li>
</ul>
</li>
<li><p>指针：指向 另外一种类型 的 复合类型。</p>
<ul>
<li><p>与引用的不同：</p>
<ul>
<li>指针本身就是对象，允许赋值拷贝，且声明周期内可以先后指向不同的对象</li>
<li>指针定义时不需要赋初值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1,*p2;		<span class="comment">//定义指针p1，p2，指向int型对象</span></span><br><span class="line"><span class="keyword">double</span> dp,*dp2;		<span class="comment">//定义double型dp，指向double型对象的指针dp2</span></span><br><span class="line"><span class="keyword">int</span> ival=<span class="number">42</span>;		</span><br><span class="line"><span class="keyword">int</span> *p=&amp;ival;		<span class="comment">//p存放ival的地址，p是指向ival的指针</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p;			<span class="comment">//使用解引用符访问ival，输出42</span></span><br><span class="line">*p=<span class="number">0</span>;				<span class="comment">//使用解引用符，给ival赋值0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p;			<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针存放某个对象的地址</p>
</li>
<li><p>除两种例外情况，指针类型要和指向的对象严格匹配</p>
</li>
</ul>
</li>
<li><p>指针值：属于以下四种状态之一</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置–不允许访问</li>
<li>空指针，未指向任何对象–不允许访问</li>
<li>无效指针，上述情况外的其他值</li>
</ul>
</li>
<li><p>访问无效指针的值会报错，和使用未初始化的变量一样。</p>
</li>
<li><p>利用指针访问对象：使用解引用符（*)</p>
<ul>
<li>仅适用于确实指向某个对象的指针</li>
</ul>
</li>
<li><p>某些符号的多重含义</p>
<ul>
<li>&amp; ：引用声明的一部分 / 取地址符</li>
<li>* :指针声明的一部分 / 解引用符</li>
</ul>
</li>
<li><p>空指针：不指向任何对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">//生成空指针p1,p2,p3</span></span><br><span class="line"><span class="keyword">int</span> *p1=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3=<span class="literal">NULL</span>;<span class="comment">//预处理变量NULL，在 cstdlib中定义 即0.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>预处理器：运行于编译之前的一段程序。预处理变量由预处理器负责管理（自动将它替换为实际值</li>
</ul>
</li>
<li><p>不能把int变量直接赋值给指针</p>
</li>
<li><p>初始化所有的指针，尽可能在定义对象后 再定义指向它的指针。或者初始化为nullptr或0.</p>
</li>
<li><p>给指针赋值就是给它一个新的地址，指向一个新的对象。</p>
</li>
<li><p>赋值永远改变的是等号左侧的对象。</p>
</li>
<li><p>任何非0指针对应的条件都是true。</p>
</li>
<li><p>比较指针的前提是都为合法指针。两个指针存放的地址相同（指针相等）有三种可能：</p>
<ul>
<li>都为空</li>
<li>都指向同一个对象</li>
<li>都指向同一个对象的下一个地址</li>
<li>一个指针指向某对象，另一个指针指向另外对象的下一个地址</li>
</ul>
</li>
<li><p>void*：特殊的指针类型，存放任意对象的地址</p>
<ul>
<li>仅指向一块内存空间，无法访问内存空间中的对象。</li>
</ul>
</li>
<li><p>指针或引用的两种写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修饰符和类型名写在一起，每条语句只定义一个变量。</span></span><br><span class="line"><span class="keyword">int</span>* p1;</span><br><span class="line"><span class="keyword">int</span>* p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修饰符和变量标识符写在一起</span></span><br><span class="line"><span class="keyword">int</span> *p1,*p2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向指针的指针</p>
<ul>
<li>使用 * 的个数区分指针的级别，如 ** 表示指向指针的指针。。。</li>
<li>解引用 int型指针 会得到一个int型的数。解引用 指向指针的指针 会得到一个指针，再解引用 就可以得到最原始的对象。</li>
</ul>
</li>
<li><p>指向指针的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;		</span><br><span class="line"><span class="keyword">int</span> *p;			<span class="comment">//int型指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r=p;		<span class="comment">//r是对指针p的引用，从右向左看，首先r是一个引用，* 说明r引用的是一个指针，是int型的指针。</span></span><br><span class="line"></span><br><span class="line">r=&amp;i;			<span class="comment">//p指针指向i</span></span><br><span class="line">*r=<span class="number">0</span>;			<span class="comment">//i赋值为0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h4><p>定义一种变量（常量） ，使它的值不能被改变</p>
<ul>
<li><p>const对象必须初始化</p>
</li>
<li><p>只能读const对象执行不改变内容的操作</p>
</li>
<li><p><strong>？</strong>const对象的常量特征 仅在改变该对象时才会发挥作用</p>
</li>
<li><p>const对象仅在文件内有效</p>
</li>
<li><p>编译器会把与const同名的变量都替换成对应的const值</p>
</li>
<li><p>只在一个文件中定义const，在其他多个文件中声明并使用它</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file1.cc文件中定义并初始化一个常量，能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize=fcn();</span><br><span class="line"><span class="comment">//file1.h文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;<span class="comment">//定义了同一个bufSize</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多个文件共享const对象，在定义之前添加extern关键字</p>
</li>
<li><p>对常量的引用</p>
<ul>
<li>引用也必须是常量类型</li>
<li><strong>无法通过常量引用修改绑定对象的值</strong></li>
<li>对const的引用可以简称为 常量引用</li>
</ul>
</li>
<li><p><strong>允许为一个 常量引用 绑定 非常量的对象、字面值或一般表达式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i;		<span class="comment">//允许将const int&amp; 绑定到int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>;		<span class="comment">//允许 r2是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3= r1 * <span class="number">2</span>;	<span class="comment">//允许 r3是一个常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4=r1*<span class="number">2</span>;			<span class="comment">//错误 r4是一个非常量引用,右边是一个字面值，非常量引用无法绑定字面值。</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用绑定到非常量对象上</span></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=dval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了确保让ri绑定一个整数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp =dval;	<span class="comment">//由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=temp;		<span class="comment">//ri绑定这个临时量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>临时量对象：如上temp，编译器需要一个空间来暂存表达式的求值结果，临时创建了一个未命名的对象。</p>
</li>
<li><p><strong>常量引用的绑定对象若为非常量</strong></p>
<ul>
<li><strong>无法通过常量引用改变绑定对象的值</strong></li>
<li><strong>可以通过直接赋值 或 绑定到非常量引用上，来更改常量引用绑定的对象的值。</strong></li>
</ul>
</li>
<li><p>指向常量的指针</p>
<ul>
<li>不能用于改变其所指对象的值</li>
<li>用于存放常量对象的地址</li>
<li><strong>可以指向非常量对象</strong><ul>
<li><strong>此时不能通过该指针修改非常量对象的值</strong></li>
<li>可以通过别的方法直接修改非常量对象的值</li>
</ul>
</li>
</ul>
</li>
<li><p>常量指针：指针是对象，因此可以是常量。（引用不是对象，没有本身是常量的引用！</p>
<ul>
<li><p>必须初始化，初始化后其值不再改变</p>
</li>
<li><p>不变的是指针本身的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> err=<span class="number">0</span>;						</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr=&amp;err;				<span class="comment">//curErr是常量指针，一直指向err</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14159</span>;			</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip=&amp;pi;		<span class="comment">//从右往左看，pip是常量指针 pip是指向double的常量指针 pip是指向double常量的常量指针。</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如上，pip是指向常量对象的常量指针，因此pip的地址和pip指向的对象值都不能改变。</p>
</li>
<li><p>curErr是指向一般int对象的常量指针，curErr的地址不能改变，但可以用curErr改变指向对象的值。</p>
</li>
</ul>
</li>
<li><p>顶层const：表示指针本身是常量；可以表示任意的对象是常量</p>
</li>
<li><p>底层const：表示指针所指的对象是常量；表示 指针和引用 等复合类型中的 基本类型部分（指针指向  引用绑定。。）</p>
</li>
<li><p>指针类型可以是顶层const，也可以是底层const（指针的指针</p>
</li>
<li><p>声明引用的const都是底层const（引用本身不是对象，不可能是常量，不可能有顶层const</p>
</li>
<li><p><strong>执行对象的拷贝</strong></p>
<ul>
<li>顶层const不受影响</li>
<li>底层const：<strong>拷入和拷出的对象必须具有相同的底层const，或两个对象的数据类型可以转换。</strong></li>
</ul>
</li>
<li><p>常量表达式：<strong>值不会改变</strong>，并且<strong>在编译过程就能得到计算结果</strong>的表达式。</p>
<ul>
<li>字面值是常量表达式</li>
<li>常量表达式初始化的常量对象 也是 常量表达式</li>
</ul>
</li>
<li><p>constexpr变量</p>
<ul>
<li>变量可声明为该类型，由编译器验证变量的值是否是常量表达式</li>
<li>constexpr变量 一定是 一个常量，且必须用常量表达式初始化。</li>
<li>如果你认定变量是一个常量表达式，就声明为constexpr类型。</li>
</ul>
</li>
<li><p>字面值类型</p>
<ul>
<li>算术类型、引用、指针都是字面值类型</li>
<li>声明constexpr的类型必须用字面值类型</li>
</ul>
</li>
<li><p>constexpr指针</p>
<ul>
<li><strong>一个constexpr的指针初始值必须为nullptr，0，或存储在固定地址中的对象</strong></li>
<li>函数体内的变量一般不存放在固定地址中，constexpr指针不能指向这样的变量；函数体外的对象地址固定，可用于初始化这种指针。</li>
<li>constexpr仅对指针有效，与其所指的对象无关</li>
<li>constexpr指针可以指向常量 或 非常量</li>
</ul>
</li>
</ul>
<h4 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h4><ul>
<li><p>类型别名</p>
<ul>
<li><p>使用typedef定义类型别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用 别名声明 定义类型的别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> A=<span class="keyword">double</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复合类型使用别名的混淆例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr=<span class="number">0</span>;<span class="comment">//cstr是指向char的常量指针！  并不是指向常量char的指针！</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;	<span class="comment">//ps是一个指针，指向 指向char的常量指针。</span></span><br><span class="line"><span class="comment">//const修饰pstring，因此 const pstring 代表指向char的常量指针</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>auto类型说明符</p>
<ul>
<li><p>由编译器通过初始值分析表达式的类型</p>
</li>
<li><p>auto定义的变量必须有初始值</p>
</li>
<li><p>auto也能在一条语句中声明多个变量，但这些变量的基本类型必须相同。</p>
</li>
<li><p>引用：编译器以引用对象的类型作为auto的类型</p>
</li>
<li><p>auto忽略顶层const，保留底层const；若希望auto是顶层const，可以手动添加： const auto…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;h=<span class="number">42</span>;				<span class="comment">//报错，auto被判为非常量引用，不能绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;h=<span class="number">42</span>;		<span class="comment">//正确，常量引用可以绑定字面值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=i;</span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci, *p = &amp;ci;	<span class="comment">//ok 两个都是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i,*p2 = &amp;ci;	<span class="comment">//报错 前一个是int 后一个是const int（p2是指向常量的指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>decltype类型指示符</p>
<p>选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，但不实际计算表达式的值。</p>
<ul>
<li><p>若decltype使用的表达式是一个变量，则返回的类型包括顶层const和<strong>引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cj=ci;</span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//注意这里，不能直接把cj换成ci理解，decltype根据cj判断：返回的类型是引用，因此z是一个引用，z未被初始化，报错。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若decltype使用的表达式不是变量，返回 表达式结果对应的类型。</p>
<ul>
<li><p>表达式内容是解引用，decltype得到引用类型</p>
</li>
<li><p>表达式若为加上括号的变量，结果是引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((variable)) <span class="comment">//结果是引用</span></span><br><span class="line"><span class="keyword">decltype</span>(variable)   <span class="comment">//只有Variable是引用，结果才会是引用</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h4><ul>
<li><p>最基本层面： <strong>数据结构</strong>–把一组相关的数据元素组织起来，然后使用它们的 <strong>策略和方法</strong>。</p>
</li>
<li><p>允许用户以类的形式自定义数据类型</p>
</li>
<li><p>类定义的最后加上分号。</p>
</li>
<li><p>类数据成员</p>
<ul>
<li>类的每个对象有自己的一份数据拷贝。</li>
<li>c++11 可以为类的数据成员提供一个类内初始值，用于初始化数据成员，否则默认初始化。</li>
</ul>
</li>
<li><p>编写头文件</p>
<ul>
<li>类通常被定义在头文件中</li>
<li>头文件通常包含 只能被定义一次的实体</li>
<li>头文件经常用到其他头文件的功能</li>
<li>头文件概念–相关源文件要重新编译，获取更新过的声明</li>
</ul>
</li>
<li><p>预处理器</p>
<p>编译之前执行的一段程序</p>
<ul>
<li><p>如#include，预处理器会用指定的头文件内容代替#include</p>
</li>
<li><p><strong>头文件保护符：防止重复包含</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H				<span class="comment">//检查预处理变量是否已定义，ifndef--未定义时为真</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H				<span class="comment">//将一个名字设为预处理变量 此时已定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如上，第一次包含时，ifndef检查结果为真，程序执行到endif，此时预处理变量SALES_DATA_H变为已定义，头文件也被拷贝到程序中；之后若重复包含该头文件，#ifndef检查结果为假，编译器忽略 #ifndef 到 #endif 的部分。</p>
</li>
<li><p>整个程序中的预处理变量必须唯一，包括头文件保护符。基于头文件中类的名字构建保护符的名字，确保其唯一性。</p>
</li>
<li><p>预处理变量名字一般大写（避免名字冲突</p>
</li>
<li><p>头文件最好设置保护符。</p>
</li>
</ul>
</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>默认初始化<ul>
<li>全局作用域：初始化为0</li>
<li>局部作用域：未定义的值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第三章</title>
    <url>/2020/07/15/c-primer-3/</url>
    <content><![CDATA[<h3 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h3><p>c++的抽象数据类型库中，string和vector是两种最重要的标准库类型，前者支持可变长字符串；后者支持可变长的集合。还有一种标准类型是迭代器，是string和vector的配套类型。</p>
<p>本章将分别介绍数组以及标准库类型string和vector。</p>
<a id="more"></a>

<h4 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>每个名字需要独立的using声明</li>
<li>头文件中不应使用using声明</li>
</ul>
<h4 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义和初始化string对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//字符c重复10次 即cccccccccc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接初始化（不使用等号）和拷贝初始化（使用等号）</p>
</li>
<li><p>string对象上的操作</p>
<ul>
<li><p>读取时，string自动忽略开头的空白，从第一个真正的字符开始读起，直到遇见下一处空白。</p>
</li>
<li><p>读取未知数量的string对象：while(cin&gt;&gt;word){…}. 流有效则循环读取。</p>
</li>
<li><p>使用getline读取一整行（包括空白符。getline返回 流参数。<strong>首先从输入流中读入内容（包括换行符），之后存入string对象（不存换行符）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,<span class="built_in">line</span>))	<span class="comment">//每次读一整行，直到文件末尾</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">line</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>empty函数，根据string对象是否为空返回bool值。<code>line.empty()</code> </p>
</li>
<li><p>size函数返回长度（string对象中字符个数）<code>line.size()</code>，返回<strong>string::size_type类型</strong>的值，<strong>无符号类型</strong>。不要在表达式中和带符号类型混用（会自动转换）</p>
</li>
<li><p>比较string对象：对大小写敏感。长度相等比字典序，否则比长度。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章更新较慢</title>
    <url>/2020/06/28/hexo%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E8%BE%83%E6%85%A2/</url>
    <content><![CDATA[<p>hexo的相关设置发布到github上生效慢，是chrome的浏览器缓存问题</p>
<h4 id="解决方法：ctrl-f5刷新chrome页面缓存"><a href="#解决方法：ctrl-f5刷新chrome页面缓存" class="headerlink" title="解决方法：ctrl+f5刷新chrome页面缓存"></a>解决方法：ctrl+f5刷新chrome页面缓存</h4>]]></content>
  </entry>
</search>
