<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++_primer_V5 学习笔记-第一章</title>
    <url>/2020/07/13/c-primer-1/</url>
    <content><![CDATA[<h3 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a>第1章 开始</h3><p>本章介绍c++的大部分基础内容：类型、变量、表达式、语句及函数。并介绍如何编译及运行程序。</p>
<a id="more"></a>

<h4 id="编写一个简单的C-程序"><a href="#编写一个简单的C-程序" class="headerlink" title="编写一个简单的C++程序"></a>编写一个简单的C++程序</h4><ul>
<li>函数定义<ul>
<li>返回类型</li>
<li>函数名</li>
<li>形参列表（允许为空</li>
<li>函数体</li>
</ul>
</li>
<li>main函数的返回类型必须为int。</li>
<li><strong>内置类型（built-in-type）：语言自身定义的类型</strong></li>
<li>函数体中使用return结束函数的执行，return返回的值与函数的返回类型相容</li>
<li>大多数系统中，main的返回值被用来指示状态，返回0表示成功，非0值常用于指出错误类型</li>
</ul>
<h5 id="编译、运行程序"><a href="#编译、运行程序" class="headerlink" title="编译、运行程序"></a>编译、运行程序</h5><ul>
<li><p>集成开发环境IDE：将编译器与其他程序创建和分析工具包装在一起</p>
</li>
<li><p>源文件：程序文件常被称为 <strong>源文件（source file</strong></p>
</li>
<li><p>源文件名字以后缀结尾：.cc .cxx .cpp .cp .C    …</p>
</li>
<li><p>命令行运行编译器</p>
<ul>
<li><p>CC是编译器程序的名字 main程序在prog1.cc中</p>
</li>
<li><p>编译器生成一个可执行文件 windows为prog1.exe unix后缀为<strong>a.out</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ CC prog1.cc</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>windows运行可执行文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ prog1</span><br><span class="line">$ .\prog1</span><br></pre></td></tr></table></figure>
</li>
<li><p>unix运行可执行文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ a.out</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>在unix和windows中，执行完程序后都可以使用 <strong>echo命令获得返回值</strong> </p>
<ul>
<li><p>unix 获得状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
</li>
<li><p>windows 查看状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">%ERRORLEVEL%</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>GNU编译器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ g++ -o prog1 prog1.cc</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-o prog1是编译器参数 指定可执行文件的文件名</p>
</li>
<li><p>该指令生成可执行文件 windows后缀为.exe UNIX无后缀</p>
</li>
<li><p>若省略 -o prog1参数 windows生成a.exe UNIX生成a.out</p>
</li>
</ul>
</li>
<li><p>微软Visual Studio编译器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">me</span>\<span class="title">Programs</span>&gt; <span class="title">c1</span> /<span class="title">EHsc</span> <span class="title">prog1.cpp</span></span></span><br></pre></td></tr></table></figure>

<p>c1调用编译器   /EHsc是编译器选项(打开标准异常处理</p>
<ul>
<li>生成可执行文件prog1.exe</li>
</ul>
</li>
<li><p>编译器可以对有问题的程序结构发出警告 打开选项</p>
<ul>
<li>GNU使用-Wall VS编译器使用/W4</li>
</ul>
</li>
</ul>
<h4 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h4><ul>
<li><p>C++语言使用 <strong>标准库</strong> 提供IO机制等</p>
</li>
<li><p>iostream库 </p>
<ul>
<li>包含istream和ostream 表示输入流和输出流</li>
<li>一个流是一个字符序列，从IO设备读出/写入IO设备</li>
</ul>
</li>
<li><p>标准输入输出对象</p>
<ul>
<li>cin 标准输入 istream类型</li>
<li>cout 标准输出 ostream类型</li>
<li>cerr 标准错误 输出警告和错误信息</li>
<li>clog 输出程序运行时的一般性信息</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用iostream库，iostream指出了一个 <strong>头文件</strong></li>
</ul>
</li>
<li><p>表达式：由运算对象和运算符组成</p>
</li>
<li><p>输出运算符&lt;&lt;   ： 接受两个运算对象 左侧为ostream对象 右侧是要打印的值 将给定值写入给定的ostream对象中</p>
</li>
<li><p>操纵符 std::endl 写入的效果是结束当前行 <strong>将与设备关联的缓冲区内容刷到设备中</strong></p>
<ul>
<li>缓冲刷新操作保证 到目前为止程序产生的输出 <strong>真正写入输出流中</strong> 而非内存中等待写入</li>
<li>调试时的打印语句应该保证一直刷新流，防止崩溃时输出还留在缓冲区 难以判断出错位置</li>
</ul>
</li>
<li><p>前缀std:: 表示定义在名为std的命名空间中   ::是作用域运算符</p>
</li>
<li><p>标准库定义的所有名字都在命名空间std中</p>
</li>
<li><p>输入运算符&gt;&gt; 左侧为istream对象 右侧为存入的对象</p>
</li>
<li><p>标准库定义了不同版本的运算符 处理不同类型的运算对象</p>
</li>
</ul>
<h4 id="注释comments-简介"><a href="#注释comments-简介" class="headerlink" title="注释comments 简介"></a>注释comments 简介</h4><ul>
<li><p>两种注释</p>
<ul>
<li>单行注释：双斜线开始，换行符结束。可以包含任何文本，包括额外的双斜线。</li>
<li>界定符对注释：以 /* 开始，以 */ 结束。可以包含除了 */ 以外的任何内容，包括换行符、</li>
</ul>
</li>
<li><p>常使用的风格：注释内的每行都以一个星号开头</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abc</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * aaaaa</span></span><br><span class="line"><span class="comment"> * aaaaa</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释界定符不能嵌套，最好的注释方式是用单行注释方式注释掉代码段的每一行。</p>
</li>
</ul>
<h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><ul>
<li><p>while语句</p>
</li>
<li><p>for语句</p>
</li>
<li><p>读取数量不定的输入数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,value=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;value)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>while使用istream对象作为条件，检测流的状态。若流是有效的，检测成功；遇到文件结束符（end-of-file）或无效输入。istream对象无效，检测条件为假。</li>
</ul>
</li>
<li><p>文件结束符：windows ctrl+Z 再enter或return UNIX输入ctrl+D</p>
</li>
<li><p>编译器：检查形式上的错误，错误信息包含行号和简短描述</p>
<ul>
<li>语法错误</li>
<li>类型错误</li>
<li>声明错误</li>
</ul>
</li>
<li><p>按照报告顺序逐个修正错误，修正后立即重新编译。</p>
</li>
<li><p>if语句</p>
</li>
<li><p>左花括号必须是形参列表后的第一个非空、非注释的字符</p>
</li>
</ul>
<h4 id="类简介（class"><a href="#类简介（class" class="headerlink" title="类简介（class"></a>类简介（class</h4><ul>
<li><p>定义类来定义自己的数据结构</p>
</li>
<li><p>在头文件中定义（后缀.h .H .hxx .hpp …)</p>
</li>
<li><p>类的作者决定了类 类型对象上可以使用的所有操作</p>
</li>
<li><p>包含标准库的头文件 使用尖括号&lt;&gt; ；不属于标准库的头文件 使用双引号””</p>
</li>
<li><p>文件重定向：将标准输入和标准输出与命名文件关联起来</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>

<p>addItems是编译后的可执行文件，则上述命令会从当前目录的 一个名为infile的文件读取数据，并将结果写入一个名为outfile的文件中</p>
</li>
<li><p>成员函数（方法：定义为类的一部分的函数</p>
</li>
<li><p>点运算符(.)：指定类的成员</p>
</li>
<li><p>调用运算符（ () ）：调用一个函数，括号内放置实参（可能没有</p>
</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>缓冲区（buffer：IO设施通常将输入或输出数据保存在一个缓冲区中，读写缓冲区的动作与程序无关。<ul>
<li>可以显式刷新输出缓冲，强制将缓冲区的数据写入输出设备</li>
<li>读cin 或 程序非正常终止 时，会刷新cout</li>
</ul>
</li>
<li>Cerr：ostream对象，写到cerr的数据默认不缓冲。常用于输出错误信息或不属于程序正常逻辑的输出内容。</li>
<li>clog：ostream对象。写到clog的数据默认缓冲。报告程序的执行信息，存入一个日志文件中。</li>
<li>main函数： <strong>每个程序有且只有一个命名为main的函数</strong></li>
<li>命名空间：将库定义的名字放在一个单一位置的机制。避免名字冲突</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第五章</title>
    <url>/2020/07/21/c-primer-5/</url>
    <content><![CDATA[<h3 id="第5章-语句"><a href="#第5章-语句" class="headerlink" title="第5章 语句"></a>第5章 语句</h3><p>本章将详细介绍c++语言支持的条件执行语句、重复执行相同代码的循环语句和用于中断当前控制流的跳转语句。</p>
<a id="more"></a>

<ul>
<li>c++语句提供了一组控制流语句以支持更复杂的执行路径</li>
</ul>
<h4 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h4><ul>
<li>表达式语句：执行表达式并丢弃求值结果</li>
<li>空语句：只含有单独的分号，常用于循环条件。使用空语句时加上注释</li>
<li>复合语句（块）：用花括号括起来的 语句和声明的序列<ul>
<li>一个块就是一个作用域，其中引入的名字只能在块内部以及子块里访问</li>
<li>块不以分号结束</li>
<li>空块：内部没有任何语句，等价于空语句</li>
</ul>
</li>
</ul>
<h4 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h4><ul>
<li>可在控制结构内自定义变量，语句结束后，变量超出其作用范围。</li>
<li>控制结构内的变量必须初始化</li>
</ul>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ul>
<li><p>if语句：根据条件决定控制流</p>
<ul>
<li>条件的类型必须能转换为布尔类型</li>
<li>嵌套if语句：使用花括号组合成块</li>
<li>悬垂else：c++规定，else与 离他最近的 且 尚未匹配的 if匹配</li>
<li>使用花括号控制执行路径</li>
</ul>
</li>
<li><p>switch语句：计算表达式的值，根据值从几条执行路径中选择一条</p>
<ul>
<li><p>break语句：中断当前的控制流</p>
</li>
<li><p>case标签：case和对应的值组成，case标签必须是 整型常量表达式</p>
</li>
<li><p>若某个case标签匹配成功，将从该标签向后顺序执行所有case分支，除非程序显式中断这一过程（如break语句）</p>
</li>
<li><p>case标签后不一定要换行，以强调它们代表的是某一范围的值</p>
</li>
<li><p>最好在标签后加上break</p>
</li>
<li><p>default标签：若所有case标签都不能匹配上switch表达式的值，执行default标签之后的语句</p>
</li>
<li><p>最好定义一个空的default标签，代表考虑了默认情况</p>
</li>
<li><p>不允许跨过变量的初始化语句，直接跳转到该变量作用域内的另一个位置</p>
<ul>
<li><p>应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之外</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> name=get_name();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	<span class="keyword">if</span>(name.empty())<span class="comment">//直接报错，name变量在作用域之外</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h4><ul>
<li>通常称为循环。while和for语句在循环前检查条件；do while先循环，再检查条件。</li>
<li>while语句：只要条件为真，就重复执行循环体。条件不能为空<ul>
<li>定义在条件部分或循环体内的变量，每次迭代都经历创建到销毁的过程</li>
<li>不确定循环次数；循环结束后要访问循环控制变量：可以用while</li>
</ul>
</li>
<li>for语句<ul>
<li>for语句头：for+初始化值+循环控制条件+初始化变量修改</li>
<li>执行流程：初始化 判断条件 若为真-执行循环 修改初始化的控制变量值</li>
<li>for语句头中定义的变量只在循环体内可见</li>
<li>for语句头的多重定义：初始化部分只能有一条声明语句，<strong>因此声明变量的基础类型必须相同</strong></li>
<li>省略语句头的任意部分：分号必须保留。</li>
<li>范围for语句（c++11）：表达式必须是一个序列（列表、数组、拥有begin/end成员的类型）<ul>
<li>可以使用auto定义变量</li>
<li>对序列元素执行写操作，<strong>循环变量要声明成引用类型</strong></li>
<li>范围for语句预存了end()的值</li>
</ul>
</li>
</ul>
</li>
<li>do while语句<ul>
<li>先执行循环体，后检查条件，至少执行一次循环</li>
<li>条件后面要用 <strong>分号</strong>表示语句结束</li>
<li>条件不能为空，循环的条件变量必须定义在循环体之外。<strong>条件部分不能定义变量</strong></li>
</ul>
</li>
</ul>
<h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><ul>
<li><p>break语句：终止最近的while dowhile for switch语句，从这些语句之后的第一条语句开始继续执行。</p>
<ul>
<li>只能出现在迭代语句或switch语句内部</li>
</ul>
</li>
<li><p>continue语句：终止最近循环中的当前迭代，立即开始下一次迭代</p>
<ul>
<li>只能出现在for while dowhile内部或嵌套。</li>
<li>只有当switch嵌套时，才能用在switch内部。</li>
</ul>
</li>
<li><p>goto语句：无条件跳转到同一函数内的另一条语句</p>
<ul>
<li><p>不要在程序中使用goto语句，难理解、难修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line"><span class="built_in">end</span>: <span class="keyword">return</span>;<span class="comment">//带标签语句，可以作为goto的目标</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转向的带标签语句必须在<strong>同一函数内</strong></p>
</li>
<li><p><strong>不能将程序的控制权从变量的作用域之外转移到作用域之内？</strong></p>
<ul>
<li>不允许跨过变量声明跳转到该变量位置</li>
</ul>
</li>
<li><p>可以跳过已经执行的定义；跳回到变量定义前，会销毁并重新创建该变量</p>
</li>
</ul>
</li>
</ul>
<h4 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h4><ul>
<li><p>异常：运行反常行为，超出函数正常功能的范围。例如失去数据库连接、遇到意外输入等</p>
</li>
<li><p>异常处理：程序检测到无法处理的问题，发出某种信号表明遇到故障，<strong>无须知道故障将在何处解决</strong></p>
</li>
<li><p>异常处理机制</p>
<ul>
<li>throw表达式：异常检测。引发（raise）异常</li>
<li>try语句块：异常处理。以try开始，若干catch子句结束。catch子句处理异常，也被称为异常处理代码。</li>
<li>异常类：在throw表达式和catch子句之间传递异常的具体信息。</li>
</ul>
</li>
<li><p>throw表达式</p>
<ul>
<li><p>关键字throw+表达式（类型为抛出的异常类型）+分号，构成表达式语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b)</span><br><span class="line">	<span class="keyword">throw</span> runtime_error(<span class="string">"ERROR!"</span>);<span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。</p>
</li>
</ul>
</li>
<li><p>try语句块</p>
<ul>
<li><p>try块+若干catch子句</p>
</li>
<li><p>catch子句包括：关键字catch+括号内的异常声明+一个块。选中catch子句处理异常之后，执行与之对应的块。</p>
</li>
<li><p>catch完成后，跳转到最后一个catch子句后的语句继续执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//执行正常情况的代码</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(runtime_error err)<span class="comment">//处理runtime_error的异常</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//异常处理</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;err.what()</span><br><span class="line">            &lt;&lt;<span class="string">"ERROR!"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>err.what()：what是runtime_error的一个成员函数，返回c风格字符串– 初始化一个具体对象所用的 string对象 的副本</p>
</li>
<li><p>函数在寻找处理代码的过程中退出</p>
<ul>
<li>抛出异常时，首先搜索抛出该异常的函数，如果没找到匹配的catch子句，终止该函数，在调用它的函数中继续寻找；若还没有找到catch，终止函数，继续在调用当前函数的函数中寻找。。。如此沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。</li>
<li>若最后也没找到catch子句，程序转到标准库函数terminate，执行该函数将导致程序非正常退出</li>
<li>对于没有try语句块定义的异常，处理方式一样。最终系统调用terminate函数并终止程序运行。</li>
</ul>
</li>
<li><p>编写 异常 安全（exception safe）的代码很困难</p>
<ul>
<li>异常中断了程序的正常流程</li>
<li>发生异常时，某些对象处理到一半就中止了，处于无效或未完成状态，资源没有正常释放</li>
<li>异常发生期间正确执行“清理”工作的程序代码即 异常 安全（exception safe）</li>
<li>异常发生后，<strong>程序如何确保对象有效</strong>、<strong>资源无泄漏</strong>、<strong>程序处于合理状态</strong>，十分关键</li>
</ul>
</li>
</ul>
</li>
<li><p>标准异常</p>
<ul>
<li>c++标准库定义的一组异常类，用于报告标准库函数遇到的问题</li>
<li>分别定义在4个头文件中：<ul>
<li>exception头文件：定义了最通用的异常类exception，只报告异常的发生，不提供额外信息</li>
<li>stdexcept头文件：定义了集中常用的异常类</li>
<li>new头文件：定义了bad_alloc异常类型</li>
<li>type_info头文件：定义了bad_cast异常类型</li>
</ul>
</li>
<li>只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，<strong>不允许赋初值</strong></li>
<li>其他异常行为需要使用string或C风格字符串初始化，<strong>不允许默认初始化</strong>，初始值含有错误相关的信息</li>
<li>异常类型只定义了一个成员函数what，该函数没有参数，返回一个指向C字符串的const char*，提供关于异常的文本信息。</li>
<li>what返回的字符串内容与异常对象的类型有关，若有字符串初始值则返回，否则由编译器决定</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>复合语句：即块</li>
<li>悬垂else</li>
<li>异常声明：catch子句中的声明</li>
<li>异常安全：抛出异常后，程序能执行正确的行为</li>
<li>控制流：程序的执行路径</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第二章</title>
    <url>/2020/07/13/c-primer-2/</url>
    <content><![CDATA[<h3 id="第I部分-C-基础-（第2章-第7章）"><a href="#第I部分-C-基础-（第2章-第7章）" class="headerlink" title="第I部分 C++基础 （第2章-第7章）"></a>第I部分 C++基础 （第2章-第7章）</h3><h3 id="第2章-变量和基本类型"><a href="#第2章-变量和基本类型" class="headerlink" title="第2章 变量和基本类型"></a>第2章 变量和基本类型</h3><p>本章主要讲述内置类型，以及c++如何支持更复杂的数据类型。</p>
<a id="more"></a>

<ul>
<li>任何编程语言都具备一组公共的语法特征。最基本的特征包括：<ul>
<li>整形、字符型等<strong>内置类型</strong></li>
<li><strong>变量</strong>，为对象命名</li>
<li><strong>表达式和语句</strong>，操纵上述类型的具体值</li>
<li><strong>控制结构</strong>，控制语句执行</li>
<li><strong>函数</strong>，定义可随时调用的计算单元</li>
</ul>
</li>
<li>大多数编程语言通过两种方式进一步补充基本特征：<ul>
<li>程序员自定义数据类型</li>
<li>将有用的功能封装成库函数</li>
</ul>
</li>
<li>C++的对象类型决定对它进行的操作。</li>
<li>C++是一种静态数据类型语言，编译时进行类型检查。编译器要知道每个变量对应的数据类型。</li>
<li>简单的编程语言，强大的<strong>数据结构自定义</strong></li>
<li>最重要的语法特征是 <strong>类class</strong> ，允许新类型包含数据和函数成员</li>
</ul>
<h4 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h4><ul>
<li><p>包括<strong>算术类型</strong>和<strong>空类型</strong></p>
</li>
<li><p>算术类型</p>
<ul>
<li>整型：包括字符和布尔类型</li>
<li>浮点型</li>
</ul>
</li>
<li><p>一个char型的大小和一个机器字节一样（8bit=1byte）</p>
</li>
<li><p>short16–int16–long32–long long64</p>
</li>
<li><p><strong>内置类型的机器实现</strong></p>
<ul>
<li>计算机以比特序列存储数据。可寻址的最小内存块为 <strong>字节byte</strong>，存储的基本单元称为 <strong>字word</strong> 。1word=4 or 8 byte = 32 or 64 bit</li>
<li>一个字节对应一个地址</li>
<li>一个字或字节的首位（bit）地址即表示这个字或字节的地址</li>
<li>如果一个对象类型是32位，计算机一个字有4个字节，那么用4个字节/1个字存储这个对象</li>
</ul>
</li>
<li><p>float单精度 6位有效数字 32位–double双精度 10位有效数字 64位–long double扩展精度 10位有效数字 96or128位</p>
</li>
<li><p>带符号和无符号类型</p>
<ul>
<li>带符号：正数 负数 0 int short long longlong。标识范围内正值和负值的量应该平衡。如8bit的char为-128-127</li>
<li>无符号：大于等于0的值 添加unsigned即无符号 如unsigned long。所有比特都用来存储值。</li>
<li>字符型分为三种：char 、signed char、unsigned char。但表现形式仍为两种：带符号、无符号。char表现为二者之一，由编译器决定</li>
</ul>
</li>
<li><p>如何选择类型</p>
<ul>
<li>数值不可能为负–使用无符号</li>
<li>整数运算用int，若超过范围使用longlong</li>
<li>算术表达式中不用char或bool</li>
<li>浮点数运算用double</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li>赋给无符号类型超出范围的值：初始值 对 无符号表示数值的总数 取模的余数，如下c=255.</li>
<li>赋给带符号类型超出范围的值：结果是未定义的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b=<span class="number">42</span>;					<span class="comment">//b=true</span></span><br><span class="line"><span class="keyword">int</span> i=b;  					<span class="comment">//i=1</span></span><br><span class="line">i=<span class="number">3.14</span>;						<span class="comment">//i=3</span></span><br><span class="line"><span class="keyword">double</span> pi=i;				<span class="comment">//pi=3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">-1</span>;			<span class="comment">//c=255  0-255区间 -1对256取模得到的余数（取模操作结果为正数） （-1 mod 256=（-1+256）mod 256=255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2=<span class="number">256</span>;			<span class="comment">//c2为未定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>避免无法预知和依赖于实现环境的行为</p>
<ul>
<li>无法预知：编译器无法检测</li>
<li>依赖于实现环境：如把int的尺寸看做确定不变的尺寸值，则程序 <strong>不可移植</strong></li>
</ul>
</li>
<li><p>bool值在算术表达式中非0即1，因此不宜在算术表达式中用bool。</p>
</li>
<li><p>含有无符号类型的表达式–例1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">-42</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; i + i &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//输出-84  （-42）+（-42）=-84</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若int占32位，输出4294967264，相加前把i（-42）转换为无符号数</span></span><br><span class="line"><span class="comment">//（-42）mod（2^32）=（2^32-42）mod（2^32）=2^32-42=4294967296-42=4294967254,也就是i转换后的值</span></span><br><span class="line"><span class="comment">//计算i+u，4294967254+10=4294967264，输出结果。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u + i &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>含有无符号类型的表达式–例2</p>
<ul>
<li>从无符号数中减去一个值时，不管这个值是不是无符号数，都必须确保结果不能是负值。否则结果为取模后的值，如下。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u1=<span class="number">42</span>,u2=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u1 - u2 &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//输出32 正确</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u2 - u1 &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//正确，但输出取模后的值 4294967264  </span></span><br><span class="line"><span class="comment">//10-42=（-32），（-32）mod（2^32）=（2^32-32）mod（2^32）=（2^32-32）= 4294967264</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无符号数+循环控制</p>
<ul>
<li><p>常使用while代替for，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> u=<span class="number">10</span>;u&gt;=<span class="number">0</span>;--u)</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出0后，执行--u。此时u=-1，转换为无符号数（取模），u=4294967295，陷入死循环。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法，使用while循环，同样输出10到0，避免执行 u取0时再减1。</span></span><br><span class="line"><span class="keyword">unsigned</span> u=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">while</span>(u&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	--u;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>切忌混用带符号类型和无符号类型，带符号数会自动转换为无符号数，出现异常结果。</p>
</li>
<li><p>字面值常量：形式和值决定它的数据类型</p>
</li>
<li><p>整型字面值：类型默认为容纳其数值的 <strong>尺寸最小的类型</strong>。 <strong>short类型没有对应的字面值。</strong></p>
<ul>
<li>八进制：0开头</li>
<li>十六进制：0x或0X开头</li>
<li>十进制：正常表示。十进制字面值不会是负数，形如-42，负号并不属于字面值，仅对字面值取负值。</li>
</ul>
</li>
<li><p>浮点型字面值默认为double</p>
</li>
<li><p>char型字面值：单引号包括</p>
</li>
<li><p>字符串型字面值:双引号包括。编译器在结尾加一个空字符（‘\0’)，字面值实际长度比内容多1。</p>
<ul>
<li><p>若字符串字面值紧邻，仅由空格、缩进、换行符分隔，则为一个整体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"aaaaaa"</span></span><br><span class="line">		<span class="string">"bbbb"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出一行字符串“aaaaaabbbb”</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>转义序列：两类字符不能直接使用，需要使用转义序列。以反斜线作为开始，被当做一个字符使用</p>
<ul>
<li>不可打印字符：退格等，无可视的图符</li>
<li>有特殊含义的字符：单双引号、问号、反斜线…</li>
</ul>
</li>
<li><p>泛化转义序列：\x后加十六进制数，或\后跟1、2或3个八进制数字。数字部分表示字符对应数值。</p>
<ul>
<li>若反斜线后跟超过3个八进制数字，只有前三个与\构成转义序列</li>
<li>\x后可以跟任意个十六进制数字</li>
</ul>
</li>
<li><p>指定字面值类型</p>
<ul>
<li>添加前缀和后缀，可以改变整型、浮点型、字符型字面值的默认类型。</li>
<li>长整型建议使用大写L标记。</li>
<li>字符和字符串用前缀指定；整型和浮点型用后缀指定。</li>
</ul>
</li>
<li><p>布尔字面值：true、false</p>
</li>
<li><p>指针字面值：nullptr</p>
</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li><p>变量提供一个具名的、可供程序操作的存储空间。</p>
</li>
<li><p>变量的数据类型决定内存大小、布局方式、存储值的范围、能参与的运算。</p>
</li>
<li><p>变量定义：类型说明符+一个或多个变量名的列表。</p>
</li>
<li><p>什么是<strong>对象</strong>？</p>
<ul>
<li>一块能<strong>存储数据</strong>并具有某种<strong>类型</strong>的<strong>内存空间</strong>。</li>
</ul>
</li>
<li><p>初始化：对象在创建时获得一个特定的值。</p>
<ul>
<li><p>同一定义语句中，可以用先定义的变量值 初始化 后定义的其他变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> price=<span class="number">109.99</span>,discount=price*<span class="number">0.16</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>初始化不是赋值！</strong></p>
<ul>
<li>初始化在创建变量是赋予一个初始值</li>
<li>赋值把对象的当前值擦除，再用一个新值替代。</li>
</ul>
</li>
<li><p>列表初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//四种初始化语句</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//列表初始化</span></span><br><span class="line"><span class="keyword">int</span> a=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>若使用列表初始化，且初始值存在丢失的风险，则编译器会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;,b=&#123;ld&#125;;<span class="comment">//使用列表初始化 编译器报错：转换未执行，存在丢失信息的风险。</span></span><br><span class="line"><span class="keyword">int</span> c&#123;ld&#125;,d=ld;<span class="comment">//不使用列表初始化 通过编译：转换执行，确实丢失了部分值。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>默认初始化</p>
<ul>
<li>定义变量时未指定初值，则默认初始化，变量被赋予默认值。</li>
<li>默认值由变量类型决定，定义变量的位置也有影响。</li>
<li>定义于函数体之外的变量被初始化为0.</li>
<li>定义在函数体内部的变量不被初始化，它的值是未定义的。若访问此类值将出错。</li>
<li>每个类决定其初始化对象的方式，以及能否不经初始化就定义对象。</li>
<li>绝大多数类 无须显示初始化 来定义对象，提供一个合适的默认值。如string类（未指定初值，则生成一个空串</li>
<li>一些类要求每个对象进行显式初始化，否则报错。</li>
</ul>
</li>
<li><p>未初始化变量会引发运行时故障</p>
<ul>
<li>建议初始化每一个内置类型的变量，确保初始化后程序安全。</li>
</ul>
</li>
<li><p>分离式编译</p>
<ul>
<li>允许将程序分割成若干个文件，每个文件独立编译。</li>
</ul>
</li>
<li><p>变量的声明和定义</p>
<ul>
<li><p>声明：名字被程序所知，文件要使用别处定义的名字，必须包含对那个名字的声明。</p>
</li>
<li><p>定义：创建与名字关联的实体。为变量申请空间，可能赋初值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;	<span class="comment">//只声明i，并未定义i</span></span><br><span class="line"><span class="keyword">int</span> j;			<span class="comment">//声明i，并且定义i</span></span><br><span class="line"><span class="comment">//extern语句若包含初始值，则变成定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.1415</span>;<span class="comment">//定义pi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明+赋初始值=定义</p>
</li>
<li><p>函数体内部，若初始化一个extern标记的变量，会报错。</p>
</li>
<li><p>变量能且只能被定义一次，但可以被多次声明。</p>
</li>
</ul>
</li>
<li><p>多个文件使用同一个变量</p>
<ul>
<li>变量定义只能出现在一个文件中</li>
<li>其他用到该变量的文件要对其声明，但不能重复定义。</li>
</ul>
</li>
<li><p>静态类型：在编译阶段 检查类型（类型检查）</p>
<ul>
<li>C++是静态类型语言</li>
<li>编译器检查数据类型是否支持要执行的运算，不支持则报错，不生成可执行文件</li>
<li>使用变量前必须声明某个类型，以便编译器进行检查。</li>
</ul>
</li>
<li><p>标识符</p>
<ul>
<li>必须以字母或下划线开头</li>
<li>对大小写字母敏感</li>
<li>不能使用标准库关键字</li>
<li>不能连续出现两个下划线，也不能下划线紧连大写字母开头。</li>
<li>函数体外的标识符不能以下划线开头。</li>
</ul>
</li>
<li><p>变量命名规范</p>
<ul>
<li>一般用小写字母</li>
<li>自定义类名一般大写字母开头</li>
<li>若标识符由多个单词组成，由大写字母或下划线分割</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li><p>多数作用域用大括号分隔</p>
</li>
<li><p>同一个名字在不同的作用域中可能指向不同的实体</p>
</li>
<li><p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> val=<span class="number">1</span>;val&lt;=<span class="number">10</span>;++val)</span><br><span class="line">		sum+=val;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"Sum of 1 to 10 inclusive is"</span></span><br><span class="line">		     &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了3个名字 main、sum、val，并使用了命名空间名字std，该空间提供了两个名字cout、cin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局作用域：main。声明后在整个程序内都可使用。</p>
</li>
<li><p>块作用域：sum。声明后到函数结束为止都可使用。</p>
</li>
<li><p>名字val仅可在for循环内访问。</p>
</li>
</ul>
</li>
<li><p>在第一次使用变量时再定义它，更容易找到定义和赋初值。</p>
</li>
<li><p>嵌套的作用域 （外层作用域（内层作用域））</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> reused=<span class="number">42</span>;					<span class="comment">//全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> unique=<span class="number">0</span>;				<span class="comment">//unique拥有块作用域</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//输出全局变量reused=42</span></span><br><span class="line">	<span class="keyword">int</span> reused=<span class="number">0</span>;				<span class="comment">//定义局部变量reused，覆盖了全局变量</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//输出局部变量reused=0</span></span><br><span class="line">    <span class="comment">//使用作用域操作符 :: ，覆盖默认的作用域规则。操作符左侧为空，默认使用全局作用域中的右侧变量。</span></span><br><span class="line">    <span class="comment">//显示访问全局变量reused，输出reused=42</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;::reused&lt;&lt;<span class="built_in">endl</span>;		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要定义和全局变量同名的局部变量。</p>
</li>
</ul>
<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>基于其他类型定义的类型。</p>
<ul>
<li><p>声明语句：由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量，并指定其为 与基本数据类型相关的类型。</p>
</li>
<li><p>引用（左值引用</p>
<ul>
<li><p>引用类型 引用 另外一种类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival=<span class="number">1024</span>;		<span class="comment">//定义int型变量ival，初始化为1024</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal=ival;	<span class="comment">//定义引用类型的变量refVal，指向ival（refVal是ival的另一个名字</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;		<span class="comment">//报错：引用必须被初始化</span></span><br><span class="line">refVal=<span class="number">2</span>;			<span class="comment">//即把2赋值给了ival</span></span><br><span class="line"><span class="keyword">int</span> ii=refVal;		<span class="comment">//ii初始化为ival的值</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3=refVal;<span class="comment">//refVal3绑定到了ival上</span></span><br><span class="line"><span class="keyword">int</span> i=refVal;		<span class="comment">//i被初始化为ival的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化后，引用会和它的初始值对象一直 绑定bind 在一起。   <strong>引用必须初始化</strong></p>
</li>
<li><p>引用不是对象，它是一个已有对象的另一个名字</p>
</li>
<li><p>无法定义引用的引用，因为引用不是对象，只能定义一个对象的引用。</p>
</li>
<li><p>除了两种例外情况，引用的类型与绑定对象严格匹配。</p>
</li>
<li><p><strong>非常量引用只能绑定在对象上，不能是字面值或计算结果。</strong></p>
</li>
<li><p>定义引用后，每次使用引用都会访问它 最初绑定的那个对象。</p>
</li>
</ul>
</li>
<li><p>指针：指向 另外一种类型 的 复合类型。</p>
<ul>
<li><p>与引用的不同：</p>
<ul>
<li>指针本身就是对象，允许赋值拷贝，且声明周期内可以先后指向不同的对象</li>
<li>指针定义时不需要赋初值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1,*p2;		<span class="comment">//定义指针p1，p2，指向int型对象</span></span><br><span class="line"><span class="keyword">double</span> dp,*dp2;		<span class="comment">//定义double型dp，指向double型对象的指针dp2</span></span><br><span class="line"><span class="keyword">int</span> ival=<span class="number">42</span>;		</span><br><span class="line"><span class="keyword">int</span> *p=&amp;ival;		<span class="comment">//p存放ival的地址，p是指向ival的指针</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p;			<span class="comment">//使用解引用符访问ival，输出42</span></span><br><span class="line">*p=<span class="number">0</span>;				<span class="comment">//使用解引用符，给ival赋值0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p;			<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针存放某个对象的地址</p>
</li>
<li><p>除两种例外情况，指针类型要和指向的对象严格匹配</p>
</li>
</ul>
</li>
<li><p>指针值：属于以下四种状态之一</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置–不允许访问</li>
<li>空指针，未指向任何对象–不允许访问</li>
<li>无效指针，上述情况外的其他值</li>
</ul>
</li>
<li><p>访问无效指针的值会报错，和使用未初始化的变量一样。</p>
</li>
<li><p>利用指针访问对象：使用解引用符（*)</p>
<ul>
<li>仅适用于确实指向某个对象的指针</li>
</ul>
</li>
<li><p>某些符号的多重含义</p>
<ul>
<li>&amp; ：引用声明的一部分 / 取地址符</li>
<li>* :指针声明的一部分 / 解引用符</li>
</ul>
</li>
<li><p>空指针：不指向任何对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">//生成空指针p1,p2,p3</span></span><br><span class="line"><span class="keyword">int</span> *p1=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3=<span class="literal">NULL</span>;<span class="comment">//预处理变量NULL，在 cstdlib中定义 即0.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>预处理器：运行于编译之前的一段程序。预处理变量由预处理器负责管理（自动将它替换为实际值</li>
</ul>
</li>
<li><p>不能把int变量直接赋值给指针</p>
</li>
<li><p>初始化所有的指针，尽可能在定义对象后 再定义指向它的指针。或者初始化为nullptr或0.</p>
</li>
<li><p>给指针赋值就是给它一个新的地址，指向一个新的对象。</p>
</li>
<li><p>赋值永远改变的是等号左侧的对象。</p>
</li>
<li><p>任何非0指针对应的条件都是true。</p>
</li>
<li><p>比较指针的前提是都为合法指针。两个指针存放的地址相同（指针相等）有三种可能：</p>
<ul>
<li>都为空</li>
<li>都指向同一个对象</li>
<li>都指向同一个对象的下一个地址</li>
<li>一个指针指向某对象，另一个指针指向另外对象的下一个地址</li>
</ul>
</li>
<li><p>void*：特殊的指针类型，存放任意对象的地址</p>
<ul>
<li>仅指向一块内存空间，无法访问内存空间中的对象。</li>
</ul>
</li>
<li><p>指针或引用的两种写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修饰符和类型名写在一起，每条语句只定义一个变量。</span></span><br><span class="line"><span class="keyword">int</span>* p1;</span><br><span class="line"><span class="keyword">int</span>* p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修饰符和变量标识符写在一起</span></span><br><span class="line"><span class="keyword">int</span> *p1,*p2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向指针的指针</p>
<ul>
<li>使用 * 的个数区分指针的级别，如 ** 表示指向指针的指针。。。</li>
<li>解引用 int型指针 会得到一个int型的数。解引用 指向指针的指针 会得到一个指针，再解引用 就可以得到最原始的对象。</li>
</ul>
</li>
<li><p>指向指针的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;		</span><br><span class="line"><span class="keyword">int</span> *p;			<span class="comment">//int型指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r=p;		<span class="comment">//r是对指针p的引用，从右向左看，首先r是一个引用，* 说明r引用的是一个指针，是int型的指针。</span></span><br><span class="line"></span><br><span class="line">r=&amp;i;			<span class="comment">//p指针指向i</span></span><br><span class="line">*r=<span class="number">0</span>;			<span class="comment">//i赋值为0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h4><p>定义一种变量（常量） ，使它的值不能被改变</p>
<ul>
<li><p>const对象必须初始化</p>
</li>
<li><p>只能读const对象执行不改变内容的操作</p>
</li>
<li><p><strong>？</strong>const对象的常量特征 仅在改变该对象时才会发挥作用</p>
</li>
<li><p>const对象仅在文件内有效</p>
</li>
<li><p>编译器会把与const同名的变量都替换成对应的const值</p>
</li>
<li><p>只在一个文件中定义const，在其他多个文件中声明并使用它</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file1.cc文件中定义并初始化一个常量，能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize=fcn();</span><br><span class="line"><span class="comment">//file1.h文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;<span class="comment">//定义了同一个bufSize</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多个文件共享const对象，在定义之前添加extern关键字</p>
</li>
<li><p>对常量的引用</p>
<ul>
<li>引用也必须是常量类型</li>
<li><strong>无法通过常量引用修改绑定对象的值</strong></li>
<li>对const的引用可以简称为 常量引用</li>
</ul>
</li>
<li><p><strong>允许为一个 常量引用 绑定 非常量的对象、字面值或一般表达式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i;		<span class="comment">//允许将const int&amp; 绑定到int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>;		<span class="comment">//允许 r2是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3= r1 * <span class="number">2</span>;	<span class="comment">//允许 r3是一个常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4=r1*<span class="number">2</span>;			<span class="comment">//错误 r4是一个非常量引用,右边是一个字面值，非常量引用无法绑定字面值。</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用绑定到非常量对象上</span></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=dval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了确保让ri绑定一个整数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp =dval;	<span class="comment">//由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=temp;		<span class="comment">//ri绑定这个临时量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>临时量对象：如上temp，编译器需要一个空间来暂存表达式的求值结果，临时创建了一个未命名的对象。</p>
</li>
<li><p><strong>常量引用的绑定对象若为非常量</strong></p>
<ul>
<li><strong>无法通过常量引用改变绑定对象的值</strong></li>
<li><strong>可以通过直接赋值 或 绑定到非常量引用上，来更改常量引用绑定的对象的值。</strong></li>
</ul>
</li>
<li><p>指向常量的指针</p>
<ul>
<li>不能用于改变其所指对象的值</li>
<li>用于存放常量对象的地址</li>
<li><strong>可以指向非常量对象</strong><ul>
<li><strong>此时不能通过该指针修改非常量对象的值</strong></li>
<li>可以通过别的方法直接修改非常量对象的值</li>
</ul>
</li>
</ul>
</li>
<li><p>常量指针：指针是对象，因此可以是常量。（引用不是对象，没有本身是常量的引用！</p>
<ul>
<li><p>必须初始化，初始化后其值不再改变</p>
</li>
<li><p>不变的是指针本身的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> err=<span class="number">0</span>;						</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr=&amp;err;				<span class="comment">//curErr是常量指针，一直指向err</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14159</span>;			</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip=&amp;pi;		<span class="comment">//从右往左看，pip是常量指针 pip是指向double的常量指针 pip是指向double常量的常量指针。</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如上，pip是指向常量对象的常量指针，因此pip的地址和pip指向的对象值都不能改变。</p>
</li>
<li><p>curErr是指向一般int对象的常量指针，curErr的地址不能改变，但可以用curErr改变指向对象的值。</p>
</li>
</ul>
</li>
<li><p>顶层const：表示指针本身是常量；可以表示任意的对象是常量</p>
</li>
<li><p>底层const：表示指针所指的对象是常量；表示 指针和引用 等复合类型中的 基本类型部分（指针指向  引用绑定。。）</p>
</li>
<li><p>指针类型可以是顶层const，也可以是底层const（指针的指针</p>
</li>
<li><p>声明引用的const都是底层const（引用本身不是对象，不可能是常量，不可能有顶层const</p>
</li>
<li><p><strong>执行对象的拷贝</strong></p>
<ul>
<li>顶层const不受影响</li>
<li>底层const：<strong>拷入和拷出的对象必须具有相同的底层const，或两个对象的数据类型可以转换。</strong></li>
</ul>
</li>
<li><p>常量表达式：<strong>值不会改变</strong>，并且<strong>在编译过程就能得到计算结果</strong>的表达式。</p>
<ul>
<li>字面值是常量表达式</li>
<li>常量表达式初始化的常量对象 也是 常量表达式</li>
</ul>
</li>
<li><p>constexpr变量</p>
<ul>
<li>变量可声明为该类型，由编译器验证变量的值是否是常量表达式</li>
<li>constexpr变量 一定是 一个常量，且必须用常量表达式初始化。</li>
<li>如果你认定变量是一个常量表达式，就声明为constexpr类型。</li>
</ul>
</li>
<li><p>字面值类型</p>
<ul>
<li>算术类型、引用、指针都是字面值类型</li>
<li>声明constexpr的类型必须用字面值类型</li>
</ul>
</li>
<li><p>constexpr指针</p>
<ul>
<li><strong>一个constexpr的指针初始值必须为nullptr，0，或存储在固定地址中的对象</strong></li>
<li>函数体内的变量一般不存放在固定地址中，constexpr指针不能指向这样的变量；函数体外的对象地址固定，可用于初始化这种指针。</li>
<li>constexpr仅对指针有效，与其所指的对象无关</li>
<li>constexpr指针可以指向常量 或 非常量</li>
</ul>
</li>
</ul>
<h4 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h4><ul>
<li><p>类型别名</p>
<ul>
<li><p>使用typedef定义类型别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用 别名声明 定义类型的别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> A=<span class="keyword">double</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复合类型使用别名的混淆例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr=<span class="number">0</span>;<span class="comment">//cstr是指向char的常量指针！  并不是指向常量char的指针！</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;	<span class="comment">//ps是一个指针，指向 指向char的常量指针。</span></span><br><span class="line"><span class="comment">//const修饰pstring，因此 const pstring 代表指向char的常量指针</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>auto类型说明符</p>
<ul>
<li><p>由编译器通过初始值分析表达式的类型</p>
</li>
<li><p>auto定义的变量必须有初始值</p>
</li>
<li><p>auto也能在一条语句中声明多个变量，但这些变量的基本类型必须相同。</p>
</li>
<li><p>引用：编译器以引用对象的类型作为auto的类型</p>
</li>
<li><p>auto忽略顶层const，保留底层const；若希望auto是顶层const，可以手动添加： const auto…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;h=<span class="number">42</span>;				<span class="comment">//报错，auto被判为非常量引用，不能绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;h=<span class="number">42</span>;		<span class="comment">//正确，常量引用可以绑定字面值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=i;</span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci, *p = &amp;ci;	<span class="comment">//ok 两个都是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i,*p2 = &amp;ci;	<span class="comment">//报错 前一个是int 后一个是const int（p2是指向常量的指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>decltype类型指示符</p>
<p>选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，但不实际计算表达式的值。</p>
<ul>
<li><p>若decltype使用的表达式是一个变量，则返回的类型包括顶层const和<strong>引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cj=ci;</span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//注意这里，不能直接把cj换成ci理解，decltype根据cj判断：返回的类型是引用，因此z是一个引用，z未被初始化，报错。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若decltype使用的表达式不是变量，返回 表达式结果对应的类型。</p>
<ul>
<li><p>表达式内容是解引用，decltype得到引用类型</p>
</li>
<li><p>表达式若为加上括号的变量，结果是引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((variable)) <span class="comment">//结果是引用</span></span><br><span class="line"><span class="keyword">decltype</span>(variable)   <span class="comment">//只有Variable是引用，结果才会是引用</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h4><ul>
<li><p>最基本层面： <strong>数据结构</strong>–把一组相关的数据元素组织起来，然后使用它们的 <strong>策略和方法</strong>。</p>
</li>
<li><p>允许用户以类的形式自定义数据类型</p>
</li>
<li><p>类定义的最后加上分号。</p>
</li>
<li><p>类数据成员</p>
<ul>
<li>类的每个对象有自己的一份数据拷贝。</li>
<li>c++11 可以为类的数据成员提供一个类内初始值，用于初始化数据成员，否则默认初始化。</li>
</ul>
</li>
<li><p>编写头文件</p>
<ul>
<li>类通常被定义在头文件中</li>
<li>头文件通常包含 只能被定义一次的实体</li>
<li>头文件经常用到其他头文件的功能</li>
<li>头文件概念–相关源文件要重新编译，获取更新过的声明</li>
</ul>
</li>
<li><p>预处理器</p>
<p>编译之前执行的一段程序</p>
<ul>
<li><p>如#include，预处理器会用指定的头文件内容代替#include</p>
</li>
<li><p><strong>头文件保护符：防止重复包含</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H				<span class="comment">//检查预处理变量是否已定义，ifndef--未定义时为真</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H				<span class="comment">//将一个名字设为预处理变量 此时已定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如上，第一次包含时，ifndef检查结果为真，程序执行到endif，此时预处理变量SALES_DATA_H变为已定义，头文件也被拷贝到程序中；之后若重复包含该头文件，#ifndef检查结果为假，编译器忽略 #ifndef 到 #endif 的部分。</p>
</li>
<li><p>整个程序中的预处理变量必须唯一，包括头文件保护符。基于头文件中类的名字构建保护符的名字，确保其唯一性。</p>
</li>
<li><p>预处理变量名字一般大写（避免名字冲突</p>
</li>
<li><p>头文件最好设置保护符。</p>
</li>
</ul>
</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>默认初始化<ul>
<li>全局作用域：初始化为0</li>
<li>局部作用域：未定义的值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第三章</title>
    <url>/2020/07/15/c-primer-3/</url>
    <content><![CDATA[<h3 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h3><p>c++的抽象数据类型库中，string和vector是两种最重要的标准库类型，前者支持可变长字符串；后者支持可变长的集合。还有一种标准类型是迭代器，是string和vector的配套类型。</p>
<p>本章将分别介绍数组以及标准库类型string和vector。</p>
<a id="more"></a>

<h4 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>每个名字需要独立的using声明</li>
<li>头文件中不应使用using声明</li>
</ul>
<h4 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义和初始化string对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//字符c重复10次 即cccccccccc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接初始化（不使用等号）和拷贝初始化（使用等号）</p>
</li>
<li><p>string对象上的操作</p>
<ul>
<li><p>读取时，string自动忽略开头的空白，从第一个真正的字符开始读起，直到遇见下一处空白。</p>
</li>
<li><p>读取未知数量的string对象：while(cin&gt;&gt;word){…}. 流有效则循环读取。</p>
</li>
<li><p>使用getline读取一整行（包括空白符。getline返回 流参数。<strong>首先从输入流中读入内容（包括换行符），之后存入string对象（不存换行符）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,<span class="built_in">line</span>))	<span class="comment">//每次读一整行，直到文件末尾</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">line</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>empty函数，根据string对象是否为空返回bool值。<code>line.empty()</code> </p>
</li>
<li><p>size函数返回长度（string对象中字符个数）<code>line.size()</code>，返回<strong>string::size_type类型</strong>的值，<strong>无符号类型</strong>。不要在表达式中和带符号类型混用（会自动转换）</p>
</li>
<li><p>比较string对象：对大小写敏感。长度相等比字典序，否则比长度。</p>
</li>
<li><p>string对象赋值：等号</p>
</li>
<li><p>相加：两个string串接</p>
<ul>
<li><p>和字面值相加：必须确保每个 + 两侧的对象至少有一个是string</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s6=s1+<span class="string">","</span>+<span class="string">"world"</span>;<span class="comment">//ok，等价于下一行</span></span><br><span class="line"><span class="built_in">string</span> s6=(s1+<span class="string">","</span>)+<span class="string">"world"</span>;<span class="comment">//每个加号两侧都至少有一个string</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符串字面值与string是 <strong>不同的类型</strong></p>
</li>
</ul>
</li>
<li><p>处理string对象中的字符</p>
<ul>
<li>cctype头文件</li>
</ul>
</li>
<li><p>C++版本的c标准库头文件</p>
<ul>
<li>c语言头文件形如name.h  c++将这些文件命名为cname，去掉了h后缀。</li>
<li>在cname头文件中定义的名字属于命名空间std，.h头文件中的不属于。</li>
<li>C++程序应使用cname的头文件，名字总在命名空间std中，更方便。</li>
</ul>
</li>
<li><p>基于范围的for语句–处理字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"aaaaaa"</span>)</span></span>;</span><br><span class="line"><span class="comment">//每行输出str的一个字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围for–改变字符串中的字符</p>
<ul>
<li><p>必须把循环变量定义为引用类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">&#123;</span><br><span class="line">	c=<span class="string">'a'</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际上改变了引用绑定的 字符串中实际字符的值</p>
</li>
</ul>
</li>
<li><p>访问string的单个字符</p>
<ul>
<li>使用下标<ul>
<li>从0计起</li>
<li>检查下标的合法性</li>
</ul>
</li>
<li>使用迭代器<ul>
<li>之后介绍….</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑 与 （&amp;&amp;）</p>
<ul>
<li>左侧运算对象为真时，再检查右侧运算对象</li>
</ul>
</li>
</ul>
<h4 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h4><ul>
<li><p>vector表示对象的集合，其中所有对象的类型都相同。每个对象有一个与之对应的索引</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="built_in">vector</span>&lt;Sales_item&gt; Sales_vec;	<span class="comment">//包含类的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;	<span class="comment">//vector对象的vector</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>vector是一个类模板</p>
<ul>
<li>模板可以看作 编译器生成类或函数编写的一份说明</li>
<li>实例化：编译器根据模板创建类或函数</li>
<li>提供额外信息指定模板到底实例化成什么样的类</li>
</ul>
</li>
<li><p>vector不是类型（是模板</p>
</li>
<li><p>vector不能包含引用（引用不是对象</p>
</li>
<li><p>定义和初始化</p>
<ul>
<li>默认初始化一个vector，创建一个空vector</li>
<li>拷贝指定初始值，类型要相同</li>
<li>列表初始化 用大括号{}</li>
</ul>
</li>
<li><p><strong>三种初始化的特点</strong></p>
<ul>
<li>拷贝初始化（=）：只能提供一个初始值</li>
<li>类内初始值只能使用 拷贝初始化 或 花括号初始化</li>
<li>初始元素值的列表，只能放在花括号里{} 进行列表初始化。</li>
</ul>
</li>
<li><p>创建指定数量的vector元素</p>
</li>
<li><p>值初始化：只提供元素数量而略去初始值。此时会创建 值初始化 的元素初值。</p>
<ul>
<li>初值由元素类型决定</li>
<li>若有些 类 类型的元素必须明确提供初值，则必须提供元素初值</li>
<li>若只提供元素数量，则只能使用 直接初始化。</li>
<li>使用圆括号和花括号区分初始化<ul>
<li>圆括号：提供的值用于构造vector（容量、元素初值….）</li>
<li>花括号：列表初始化vector，括号内的值与元素类型匹配；若括号中的值不能列表初始化，则考虑构造vector</li>
</ul>
</li>
</ul>
</li>
<li><p>向vector对象中添加元素</p>
<ul>
<li>push_back：将一个值压到vector的尾端</li>
<li>vector对象能高效增长，不需要先设定大小。先定义空vector，再加入具体值。</li>
<li>不能用for循环向vector添加元素。for语句体内不应改变其遍历序列的大小。</li>
</ul>
</li>
<li><p>其他vector操作</p>
<ul>
<li>for语句修改所有元素（若赋值需要用引用类型）</li>
<li>两个vector比较 依据字典序。前提是vector中元素的值可比较。</li>
<li>计算vector对象的索引，确认下标在合理范围内</li>
<li>不能用下标形式添加vector元素，要用push_back</li>
<li>只能对确定已存在的元素执行下标操作，否则会出现 缓冲区溢出  的错误。 尽可能使用for语句确保下标合法。</li>
</ul>
</li>
</ul>
<h4 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h4><p>所有标准库容器都可以使用迭代器，但只有少部分也支持下标。</p>
<p>迭代器也提供了对 对象 的间接访问。</p>
<p>有效的迭代器：指向某个元素 或 指向容器中尾元素的下个位置</p>
<ul>
<li>使用迭代器<ul>
<li>有迭代器的类型也拥有 返回迭代器的成员</li>
<li>begin成员：返回 指向第一个元素的迭代器</li>
<li>end成员： 返回 指向容器（或string）“尾元素的下一个位置”的迭代器（尾后迭代器</li>
<li>容器为空，则begin和end指向同一个迭代器（尾后迭代器</li>
<li>不在意迭代器的准确类型，可用auto</li>
<li>迭代器相等：指向的元素相同，或指向同一个尾后迭代器</li>
<li>解引用（*）迭代器来获取所指元素，前提是迭代器合法且有所指。</li>
<li>end返回的迭代器不能递增或解引用</li>
<li><strong>泛型编程</strong>：c++ 比如在for循环中，尽可能使用迭代器和!= == ，所有标准库容器都定义了。但很多都没有定义&lt;和&gt;。</li>
<li>迭代器类型：标准库使用iterator、const_iterator表示。const_iterator和常量指针类似</li>
<li>迭代器：认定某个类型是迭代器–它支持一套操作，使我们能访问容器的元素 或 从某一个元素移动到另外一个元素</li>
<li>begin和end返回的类型由对象是否是常量决定 iterator 或const_iterator</li>
<li>cbegin，cend一定返回const_iterator</li>
<li>箭头运算符：解引用+成员访问</li>
<li>任何一种改变vector容量的操作，都会使它的迭代器失效。若循环体使用了迭代器，不要向对应容器添加元素。</li>
</ul>
</li>
<li>迭代器运算<ul>
<li>算术运算<ul>
<li>迭代器距离，类型为difference_type 带符号整型。</li>
</ul>
</li>
<li>使用迭代器运算<ul>
<li>二分搜索：有序序列中寻找给定值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>存放 类型相同的对象 的容器。数组大小确定不变，不能随意向数组中添加元素。</p>
</li>
<li><p>不清楚元素确切个数–用vector</p>
</li>
<li><p>定义和初始化内置数组</p>
<ul>
<li><p>维度：数组元素的个数，必须是常量表达式。</p>
</li>
<li><p>数组元素被默认初始化。若在函数体内，默认初始化后，数组就会含有未定义的值</p>
</li>
<li><p>定义数组不能用auto推断列表</p>
</li>
<li><p>显示初始化：剩余元素被初始化为默认值。</p>
</li>
<li><p>字符串初始化字符数组时，要注意：字符串结尾有一个空字符。注意数组维度</p>
</li>
<li><p>不允许数组拷贝和赋值。一些编译器扩展支持数组赋值，但最好避免使用非标准特性。</p>
</li>
<li><p><strong>复杂的数组声明</strong>：从内向外阅读，优先级最高的决定这是什么</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];					<span class="comment">//指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]=<span class="comment">/* ??? */</span>;		<span class="comment">//引用的数组 不存在这种，引用不是对象</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>]= &amp;arr;		<span class="comment">//数组的指针</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]= arr;			<span class="comment">//数组的引用</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>]= ptrs;			<span class="comment">//指针的数组的引用</span></span><br><span class="line"><span class="keyword">int</span> (*(&amp;x))[<span class="number">10</span>]=Parray;  		<span class="comment">//数组的指针的引用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问数组元素</p>
<ul>
<li>数组下标为size_t类型 无符号类型。在cstddef头文件中定义</li>
<li>下标运算符由c++语言直接定义</li>
<li>for语句遍历数组所有元素</li>
<li>注意检查下标的值是否合法</li>
</ul>
</li>
<li><p>指针和数组</p>
<ul>
<li>对数组元素取地址，可以得到指向该元素的指针</li>
<li>编译器会将数组转换为 指向首元素的指针</li>
<li>auto的初始值是数组时，会得到指针类型；但decltype返回的类型是数组</li>
<li>数组的指针也是迭代器，同样，不能对尾后指针进行解引用或递增等操作。</li>
<li>begin和end函数：将数组作为参数。分别返回首元素指针和尾后指针。 注意尾后指针不能解引用和递增</li>
<li>指针运算：相减的结果类型是ptrdiff_t类型，是带符号类型，也定义在cstddef头文件中<ul>
<li>运算同样适用于空指针 和 指向非数组的指针</li>
</ul>
</li>
<li>解引用和指针运算的交互</li>
<li>下标与指针：使用下标运算符时，编译器对指向数组的指针执行下标运算<ul>
<li>·和标准库的string  vector 不同（下标无符号） ，<strong>数组的下标运算符可以处理负值</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>C风格字符串</p>
<ul>
<li>c++程序中最好不要使用</li>
<li>C风格字符串是一种写法，字符串存在字符数组中，并以空字符结束。(‘\0’) 一般用指针操作</li>
<li>C标准库string函数：定义在cstring头文件中。<ul>
<li>传入此类函数的指针 <strong>必须指向空字符结尾的数组</strong></li>
</ul>
</li>
<li>比较字符串：与比较string不同。若直接使用运算符比较，实际比较的是 指向数组首元素的指针<ul>
<li>若两个指针未指向同一对象，将得到未定义的结果</li>
<li>需要调用strcmp函数，比较字符串</li>
</ul>
</li>
<li>使用strcpy和strcat函数拷贝和连接字符串数组，需要预先考虑数组大小。</li>
<li>因此尽可能使用标准库的string，更安全也更高效</li>
</ul>
</li>
<li><p>与旧代码的接口</p>
<ul>
<li>C++程序与旧代码的衔接</li>
<li>混用string和c风格字符串<ul>
<li>用空字符结尾的字符数组初始化string</li>
<li>相关运算中，允许使用空字符结尾的数组作为 <strong>其中一个运算对象</strong></li>
<li>string的成员函数c_str，返回一个c风格的字符串（返回指针指向空字符结尾的数组，指针类型为const char*。</li>
<li>使用c_str函数，最好拷贝一份返回的数组进行后续操作</li>
</ul>
</li>
<li>数组初始化vector对象<ul>
<li>指明拷贝区域的首元素地址和尾后地址（使用对应指针构造）</li>
</ul>
</li>
<li>C++程序尽量使用vector和迭代器，避免使用内置数组和指针；尽量使用string，避免使用c风格字符串</li>
</ul>
</li>
</ul>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>C++的多维数组，其实是数组的数组。</p>
<ul>
<li>二维数组 第一维称为行，第二维称为列</li>
<li>多维数组的初始化：花括号括起来的一组值初始化</li>
<li>多维数组的下标引用：每个维度对应一个下标运算符</li>
<li>范围for语句处理多维数组<ul>
<li>若要改变元素的值，需要把控制变量声明为引用类型</li>
<li><strong>除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。防止外层变量被自动转成指针，内层就开始在指针内遍历（不合法）。</strong></li>
</ul>
</li>
<li>指针和多维数组<ul>
<li>程序使用多维数组的名字时，也会自动将其转换为指向首元素的指针，实际上是指向第一个内层数组的指针。</li>
<li>可以使用auto或decltype，避免声明指针时，在数组前面加上指针类型。</li>
<li>类型别名 简化 多维数组的指针</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>string对象是一个可变长的字符序列</li>
<li>vector对象是一组同类型对象的容器</li>
<li>迭代器允许对容器中的对象进行间接访问，可以用于访问string和vector的元素或在元素间移动</li>
<li>数组和 指向数组的指针在一个较低的层次上实现了与标准库类型string和vector类似的功能。一般来说，应该优先选用标准库提供的类型，之后再考虑c++语言内置的底层替代品：数组和指针。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第四章</title>
    <url>/2020/07/17/c-primer-4/</url>
    <content><![CDATA[<h3 id="第4章-表达式"><a href="#第4章-表达式" class="headerlink" title="第4章 表达式"></a>第4章 表达式</h3><p>本章主要介绍由语言本身定义、并用于内置类型运算对象的运算符，同时简单介绍几种标准库定义的运算符。</p>
<a id="more"></a>

<p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量本身的值。</p>
<p>把 一个运算符 和 一个或多个运算对象 组合起来，可以生成较复杂的表达式。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li>基本概念<ul>
<li>一元运算符：作用于一个运算对象，如取地址符&amp;、解引用符*</li>
<li>二元运算符：作用于两个运算对象，如相等==、乘法*</li>
<li>三元运算符</li>
<li>函数调用：特殊的运算符，对运算对象的数量没有限制</li>
<li>一些符号能作为一元运算符、也能作为二元运算符，由上下文决定</li>
<li>组合运算符与运算对象：优先级、结合律、运算对象的求值顺序</li>
<li>运算对象转换：表达式求值时转换类型，小尺寸的整数类型常常被提升为大尺寸的整数类型</li>
<li>重载运算符：运算符作用于类 类型的运算对象时，用户可以自行定义其含义，即重载运算符。<ul>
<li>重载运算符可以定义运算对象的类型和返回值的类型，但对象个数、运算符优先级和结合律无法改变</li>
</ul>
</li>
<li>左值和右值：c++的表达式不是右值就是左值<ul>
<li>对象被用作右值：使用对象的值（内容</li>
<li>对象被用作左值：使用对象的身份（在内存中的位置</li>
<li>需要右值的地方可以用左值（也使用对象的内容）；需要左值的地方不能用右值</li>
<li>使用decltype时，若表达式结果是左值，得到一个引用类型</li>
</ul>
</li>
</ul>
</li>
<li>优先级与结合律<ul>
<li>复合表达式：含有两个或多个运算符的表达式。优先级和结合律决定了运算对象组合的方式，括号无视上述规则。</li>
<li>高优先级运算符的运算对象比低优先级更紧密地结合在一起。</li>
<li>若运算符的优先级相同，将按照从左向右的顺序组合运算对象。</li>
</ul>
</li>
<li>求值顺序<ul>
<li>若运算符没有指定执行顺序，若表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</li>
<li>4种运算符规定了求值顺序：逻辑与 逻辑或 条件运算符?:  逗号运算符，</li>
<li>运算对象的求值顺序与优先级 结合律无关</li>
<li>处理复合表达式<ul>
<li>用括号强制让表达式的组合关系符合程序的逻辑要求</li>
<li>若改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象</li>
<li>若改变运算对象的子表达式本身 就是 另外一个子表达式的运算对象时，该规则无效。<code>*++iter</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><ul>
<li>能作用于任意算术类型（或能转换成算术类型的类型）</li>
<li>运算对象和求值结果都是右值。</li>
<li>表达式求值前，小整数类型会被提升为大整数类型，最终所有运算对象转换为同一种类型。</li>
<li>一元正号运算符、加减运算符都能作用于指针，返回运算对象的一个副本。</li>
<li>bool值不应该参与运算，会先被提升为int类型，造成相关错误。（bool值1求负号，变int型-1 转回bool 还是true）</li>
<li>溢出和其他算术运算异常<ul>
<li>除数是0 产生未定义结果</li>
<li>溢出：计算结果超出该类型能表示的范围。结果不可预知，可能环绕，即符号位溢出被修改。</li>
</ul>
</li>
<li>整数相除商还是整数，弃掉商的小数部分</li>
<li>%取余：运算对象必须是整数类型。若m%n不等于0，则符号和m相同</li>
</ul>
<h4 id="逻辑运算符和关系运算符"><a href="#逻辑运算符和关系运算符" class="headerlink" title="逻辑运算符和关系运算符"></a>逻辑运算符和关系运算符</h4><ul>
<li>逻辑运算符和关系运算符的返回值都是bool类型，运算对象和求值结果都是右值。</li>
<li>逻辑与 和 逻辑或<ul>
<li>先求左侧值，再求右侧值；</li>
<li>短路求值：左侧运算对象无法确定 表达式结果 时，才会计算右侧表达式的值</li>
</ul>
</li>
<li>基于范围的for循环中，将其中的元素声明为引用类型，可以避免对过大元素的拷贝</li>
<li>逻辑非</li>
<li>关系运算符<ul>
<li>关系运算符尽量不要连写，可以用 逻辑与 连接</li>
</ul>
</li>
<li>相等性测试与布尔字面值<ul>
<li>比较运算时，除非比较的对象是bool型，不要用bool字面值true或false作为比较对象</li>
</ul>
</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ul>
<li>赋值运算的结果是它的左侧运算对象，并且是一个左值。结果的类型是左侧运算对象的类型。</li>
<li>若左右类型不同，右侧运算对象会转为左侧对象的类型</li>
<li>C++11允许花括号括起来的初始值列表作为右侧对象<ul>
<li>初始列表为空时，编译器创建一个值初始化的临时量，赋给左侧对象。</li>
</ul>
</li>
<li>赋值运算符满足 右结合律</li>
<li>多重赋值语句：其中的每一个对象，类型与右边对象相同，或可由右边对象类型转换得到。</li>
<li>赋值运算符优先级 &lt; 关系运算符优先级，条件语句中，赋值部分加括号。</li>
<li>切勿混淆赋值运算符和相等运算符</li>
<li>复合赋值运算符：相比普通运算符（求值两次），复合运算符只求值一次。</li>
</ul>
<h4 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h4><ul>
<li><p>前置和后置</p>
<ul>
<li>前置：运算对象先加1，然后将改变后的对象作为求值结果。将对象本身作为左值返回。</li>
<li>后置：运算对象加1，求值结果是 改变前的运算对象的副本。将 对象原始值的副本 作为右值返回。</li>
<li>尽可能不用后置版本，需要存储原始值，这种操作可能是一种浪费。</li>
</ul>
</li>
<li><p>混用解引用和递增</p>
<ul>
<li><p>后置递增优先级 &gt; 解引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg=v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(pbeg!=v.<span class="built_in">end</span>() &amp;&amp; *pbeg&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; *pbeg++ &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出当前pbeg指向的值，并将指针pbeg向前移动一个位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(pbeg++) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//等价于上面一句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>赋值运算符左右两端用到了同一个运算对象并改变了值。可能出现未知错误</p>
</li>
</ul>
<h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h4><ul>
<li>点运算符：获取类对象的一个成员。结果和成员所属的对象一致。成员所属对象是左值，结果就是左值。</li>
<li>箭头运算符：作用于指针类型的运算对象，结果是一个左值。</li>
</ul>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><ul>
<li>把简单的if-else逻辑嵌入到单个表达式中。</li>
<li>cond ?expr1:expr2</li>
<li>首先求cond 的值，若条件为真，对expr1求值并返回，否则对expr2求值并返回。</li>
<li>嵌套条件运算符</li>
<li>条件运算符满足 右结合律</li>
<li>嵌套不宜过多</li>
<li>条件运算符优先级很低，在长表达式中通常要加括号</li>
</ul>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ul>
<li>作用于整数类型的运算对象，并把运算对象看成二进制位的集合</li>
<li>提供检查和设置二进制位的功能</li>
<li>小整型的对象值会被提升为较大的整数类型</li>
<li>处理有符号类型的结果未知（依赖机器），因此尽量处理无符号类型</li>
<li>移位运算符<ul>
<li>&lt;&lt;和&gt;&gt;：对运算对象执行基于二进制位的移动操作</li>
<li>右侧运算对象不能为负，且其值严格小于结果的位数。否则会产生未定义结果。</li>
<li>移出边界外的位数被舍弃</li>
</ul>
</li>
<li>位求反运算符<ul>
<li>char类型先提升成int型</li>
</ul>
</li>
<li>位与、位或、位异或运算符</li>
<li>移位（IO）运算符满足左结合律</li>
</ul>
<h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><ul>
<li><p>返回一条表达式或一个类型名字所占的字节数</p>
</li>
<li><p>满足右结合律</p>
</li>
<li><p>运算对象</p>
<ul>
<li>类型：返回类型大小</li>
<li>表达式结果：返回结果的类型大小,并不计算实际对象的值</li>
</ul>
</li>
<li><p>对象可以是未定义的指针，因为不计算具体值，指针并没有被真正使用</p>
</li>
<li><p>c++11允许使用作用域运算符来获取类成员的大小</p>
</li>
<li><p>sizeof运算符结果依赖于作用的类型</p>
<ul>
<li>对char执行，结果为1</li>
<li>对引用执行：得到被引用对象所占空间大小</li>
<li>对指针执行：得到指针本身所占空间大小</li>
<li>对解引用指针执行：得到指针指向对象所占空间大小，指针不需要有效。</li>
<li>对数组执行：得到整个数组所占空间大小，等价于对其中每个元素执行并求和。不会把数组转换为指针处理</li>
<li>对string或vector处理：只返回该类型固定部分的大小，不计算其中的元素占多少空间</li>
</ul>
</li>
<li><p>可以用数组大小除以单个元素大小，得到数组元素个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia) / <span class="keyword">sizeof</span>(*ia);</span><br><span class="line"><span class="keyword">int</span> arr2[sz];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><ul>
<li>两个运算对象，求值顺序从左到右</li>
<li><strong>首先对左侧表达式求值，然后丢弃求值结果。真正的结果是右侧表达式的值</strong></li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li>如果两种类型可以相互转换，那么它们就是关联的</li>
<li>隐式转换：自动执行类型转换，尽可能避免损失精度</li>
<li>何时发生隐式转换：<ul>
<li>比int小的整数类型提升</li>
<li>非布尔转换为布尔</li>
<li>初始化时，初始值转换为变量类型；赋值语句中，右侧对象转换为左侧对象类型</li>
<li>算术运算或关系运算的对象有多种类型，需要转换为同一种</li>
<li>函数调用时</li>
</ul>
</li>
<li>算术转换：一种算术类型转换为另一种算术类型<ul>
<li>运算符的运算对象转换为最宽的类型</li>
<li>表达式中既有浮点又有整数，整数转浮点</li>
<li>无符号运算对象：整型提升-&gt;有无符号也有带符号类型<ul>
<li>无符号类型大于带符号类型：带符号转为无符号</li>
<li>无符号类型小于带符号类型：转换结果依赖机器，看无符号的所有值能否都存在带符号类型中，能就转为带符号</li>
</ul>
</li>
<li>其他隐式类型转换<ul>
<li>数组转换为指针</li>
<li>指针的转换</li>
<li>转换为布尔类型：0-false</li>
<li>转换成常量：将指向非常量类型的指针转换为指向相应常量的指针</li>
<li>类类型定义的转换：</li>
</ul>
</li>
</ul>
</li>
<li>显式转换<ul>
<li>强制类型转换</li>
<li>cast-name&lt; type &gt;(expression):cast-name指定执行哪一种转换，type是转换的目标类型，expression是待转换的值</li>
<li>执行哪一种转换<ul>
<li>static_cast：不包含底层const就可以用，较大的算数类型赋值给较小的类型；编译器无法自动执行的类型转换</li>
<li>const_cast：只能改变运算对象的底层const，常量转非常量（去const），对象只能改变常量属性</li>
<li>reinterpret_cast：为运算对象的位模式提供较低层次的重新解释。如改int指针为char指针，但所指还是int型对象。很可能在运行时引发错误</li>
<li>dynamic_cast</li>
</ul>
</li>
<li>避免强制类型转换</li>
<li>旧式的强制类型转换：表现形式不那么清晰</li>
</ul>
</li>
</ul>
<h4 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h4><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>对于超过一个运算符的表达式，理解其含义需要关键要理解优先级、结合律和求值顺序</li>
<li>大多数运算符并不明确规定运算对象的求值顺序：编译器有权自由选择先对左侧或右侧运算对象求值；如果两个运算对象指向同一个对象，且其中一个改变了对象的值，就会导致程序的严重缺陷</li>
<li>运算对象经常从原始类型自动转换成某种关联的类型，若需要的话，也可以进行显式的类型转换</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>算术转换</li>
<li>隐式转换</li>
<li>整型提升</li>
<li>短路求值</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章更新较慢</title>
    <url>/2020/06/28/hexo%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E8%BE%83%E6%85%A2/</url>
    <content><![CDATA[<p>hexo的相关设置发布到github上生效慢，是chrome的浏览器缓存问题</p>
<h4 id="解决方法：ctrl-f5刷新chrome页面缓存"><a href="#解决方法：ctrl-f5刷新chrome页面缓存" class="headerlink" title="解决方法：ctrl+f5刷新chrome页面缓存"></a>解决方法：ctrl+f5刷新chrome页面缓存</h4>]]></content>
  </entry>
</search>
