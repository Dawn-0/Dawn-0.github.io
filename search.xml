<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++_primer_V5 学习笔记-第一章</title>
    <url>/2020/07/13/c-primer-1/</url>
    <content><![CDATA[<h3 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a>第1章 开始</h3><p>本章介绍c++的大部分基础内容：类型、变量、表达式、语句及函数。并介绍如何编译及运行程序。</p>
<a id="more"></a>

<h4 id="编写一个简单的C-程序"><a href="#编写一个简单的C-程序" class="headerlink" title="编写一个简单的C++程序"></a>编写一个简单的C++程序</h4><ul>
<li>函数定义<ul>
<li>返回类型</li>
<li>函数名</li>
<li>形参列表（允许为空</li>
<li>函数体</li>
</ul>
</li>
<li>main函数的返回类型必须为int。</li>
<li><strong>内置类型（built-in-type）：语言自身定义的类型</strong></li>
<li>函数体中使用return结束函数的执行，return返回的值与函数的返回类型相容</li>
<li>大多数系统中，main的返回值被用来指示状态，返回0表示成功，非0值常用于指出错误类型</li>
</ul>
<h5 id="编译、运行程序"><a href="#编译、运行程序" class="headerlink" title="编译、运行程序"></a>编译、运行程序</h5><ul>
<li><p>集成开发环境IDE：将编译器与其他程序创建和分析工具包装在一起</p>
</li>
<li><p>源文件：程序文件常被称为 <strong>源文件（source file</strong></p>
</li>
<li><p>源文件名字以后缀结尾：.cc .cxx .cpp .cp .C    …</p>
</li>
<li><p>命令行运行编译器</p>
<ul>
<li><p>CC是编译器程序的名字 main程序在prog1.cc中</p>
</li>
<li><p>编译器生成一个可执行文件 windows为prog1.exe unix后缀为<strong>a.out</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ CC prog1.cc</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>windows运行可执行文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ prog1</span><br><span class="line">$ .\prog1</span><br></pre></td></tr></table></figure>
</li>
<li><p>unix运行可执行文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ a.out</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>在unix和windows中，执行完程序后都可以使用 <strong>echo命令获得返回值</strong> </p>
<ul>
<li><p>unix 获得状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
</li>
<li><p>windows 查看状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">%ERRORLEVEL%</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>GNU编译器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ g++ -o prog1 prog1.cc</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-o prog1是编译器参数 指定可执行文件的文件名</p>
</li>
<li><p>该指令生成可执行文件 windows后缀为.exe UNIX无后缀</p>
</li>
<li><p>若省略 -o prog1参数 windows生成a.exe UNIX生成a.out</p>
</li>
</ul>
</li>
<li><p>微软Visual Studio编译器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">me</span>\<span class="title">Programs</span>&gt; <span class="title">c1</span> /<span class="title">EHsc</span> <span class="title">prog1.cpp</span></span></span><br></pre></td></tr></table></figure>

<p>c1调用编译器   /EHsc是编译器选项(打开标准异常处理</p>
<ul>
<li>生成可执行文件prog1.exe</li>
</ul>
</li>
<li><p>编译器可以对有问题的程序结构发出警告 打开选项</p>
<ul>
<li>GNU使用-Wall VS编译器使用/W4</li>
</ul>
</li>
</ul>
<h4 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h4><ul>
<li><p>C++语言使用 <strong>标准库</strong> 提供IO机制等</p>
</li>
<li><p>iostream库 </p>
<ul>
<li>包含istream和ostream 表示输入流和输出流</li>
<li>一个流是一个字符序列，从IO设备读出/写入IO设备</li>
</ul>
</li>
<li><p>标准输入输出对象</p>
<ul>
<li>cin 标准输入 istream类型</li>
<li>cout 标准输出 ostream类型</li>
<li>cerr 标准错误 输出警告和错误信息</li>
<li>clog 输出程序运行时的一般性信息</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用iostream库，iostream指出了一个 <strong>头文件</strong></li>
</ul>
</li>
<li><p>表达式：由运算对象和运算符组成</p>
</li>
<li><p>输出运算符&lt;&lt;   ： 接受两个运算对象 左侧为ostream对象 右侧是要打印的值 将给定值写入给定的ostream对象中</p>
</li>
<li><p>操纵符 std::endl 写入的效果是结束当前行 <strong>将与设备关联的缓冲区内容刷到设备中</strong></p>
<ul>
<li>缓冲刷新操作保证 到目前为止程序产生的输出 <strong>真正写入输出流中</strong> 而非内存中等待写入</li>
<li>调试时的打印语句应该保证一直刷新流，防止崩溃时输出还留在缓冲区 难以判断出错位置</li>
</ul>
</li>
<li><p>前缀std:: 表示定义在名为std的命名空间中   ::是作用域运算符</p>
</li>
<li><p>标准库定义的所有名字都在命名空间std中</p>
</li>
<li><p>输入运算符&gt;&gt; 左侧为istream对象 右侧为存入的对象</p>
</li>
<li><p>标准库定义了不同版本的运算符 处理不同类型的运算对象</p>
</li>
</ul>
<h4 id="注释comments-简介"><a href="#注释comments-简介" class="headerlink" title="注释comments 简介"></a>注释comments 简介</h4><ul>
<li><p>两种注释</p>
<ul>
<li>单行注释：双斜线开始，换行符结束。可以包含任何文本，包括额外的双斜线。</li>
<li>界定符对注释：以 /* 开始，以 */ 结束。可以包含除了 */ 以外的任何内容，包括换行符、</li>
</ul>
</li>
<li><p>常使用的风格：注释内的每行都以一个星号开头</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abc</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * aaaaa</span></span><br><span class="line"><span class="comment"> * aaaaa</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释界定符不能嵌套，最好的注释方式是用单行注释方式注释掉代码段的每一行。</p>
</li>
</ul>
<h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><ul>
<li><p>while语句</p>
</li>
<li><p>for语句</p>
</li>
<li><p>读取数量不定的输入数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,value=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;value)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>while使用istream对象作为条件，检测流的状态。若流是有效的，检测成功；遇到文件结束符（end-of-file）或无效输入。istream对象无效，检测条件为假。</li>
</ul>
</li>
<li><p>文件结束符：windows ctrl+Z 再enter或return UNIX输入ctrl+D</p>
</li>
<li><p>编译器：检查形式上的错误，错误信息包含行号和简短描述</p>
<ul>
<li>语法错误</li>
<li>类型错误</li>
<li>声明错误</li>
</ul>
</li>
<li><p>按照报告顺序逐个修正错误，修正后立即重新编译。</p>
</li>
<li><p>if语句</p>
</li>
<li><p>左花括号必须是形参列表后的第一个非空、非注释的字符</p>
</li>
</ul>
<h4 id="类简介（class"><a href="#类简介（class" class="headerlink" title="类简介（class"></a>类简介（class</h4><ul>
<li><p>定义类来定义自己的数据结构</p>
</li>
<li><p>在头文件中定义（后缀.h .H .hxx .hpp …)</p>
</li>
<li><p>类的作者决定了类 类型对象上可以使用的所有操作</p>
</li>
<li><p>包含标准库的头文件 使用尖括号&lt;&gt; ；不属于标准库的头文件 使用双引号””</p>
</li>
<li><p>文件重定向：将标准输入和标准输出与命名文件关联起来</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ addItems &lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>

<p>addItems是编译后的可执行文件，则上述命令会从当前目录的 一个名为infile的文件读取数据，并将结果写入一个名为outfile的文件中</p>
</li>
<li><p>成员函数（方法：定义为类的一部分的函数</p>
</li>
<li><p>点运算符(.)：指定类的成员</p>
</li>
<li><p>调用运算符（ () ）：调用一个函数，括号内放置实参（可能没有</p>
</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>缓冲区（buffer：IO设施通常将输入或输出数据保存在一个缓冲区中，读写缓冲区的动作与程序无关。<ul>
<li>可以显式刷新输出缓冲，强制将缓冲区的数据写入输出设备</li>
<li>读cin 或 程序非正常终止 时，会刷新cout</li>
</ul>
</li>
<li>Cerr：ostream对象，写到cerr的数据默认不缓冲。常用于输出错误信息或不属于程序正常逻辑的输出内容。</li>
<li>clog：ostream对象。写到clog的数据默认缓冲。报告程序的执行信息，存入一个日志文件中。</li>
<li>main函数： <strong>每个程序有且只有一个命名为main的函数</strong></li>
<li>命名空间：将库定义的名字放在一个单一位置的机制。避免名字冲突</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第四章</title>
    <url>/2020/07/17/c-primer-4/</url>
    <content><![CDATA[<h3 id="第4章-表达式"><a href="#第4章-表达式" class="headerlink" title="第4章 表达式"></a>第4章 表达式</h3><p>本章主要介绍由语言本身定义、并用于内置类型运算对象的运算符，同时简单介绍几种标准库定义的运算符。</p>
<a id="more"></a>

<p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量本身的值。</p>
<p>把 一个运算符 和 一个或多个运算对象 组合起来，可以生成较复杂的表达式。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li>基本概念<ul>
<li>一元运算符：作用于一个运算对象，如取地址符&amp;、解引用符*</li>
<li>二元运算符：作用于两个运算对象，如相等==、乘法*</li>
<li>三元运算符</li>
<li>函数调用：特殊的运算符，对运算对象的数量没有限制</li>
<li>一些符号能作为一元运算符、也能作为二元运算符，由上下文决定</li>
<li>组合运算符与运算对象：优先级、结合律、运算对象的求值顺序</li>
<li>运算对象转换：表达式求值时转换类型，小尺寸的整数类型常常被提升为大尺寸的整数类型</li>
<li>重载运算符：运算符作用于类 类型的运算对象时，用户可以自行定义其含义，即重载运算符。<ul>
<li>重载运算符可以定义运算对象的类型和返回值的类型，但对象个数、运算符优先级和结合律无法改变</li>
</ul>
</li>
<li>左值和右值：c++的表达式不是右值就是左值<ul>
<li>对象被用作右值：使用对象的值（内容</li>
<li>对象被用作左值：使用对象的身份（在内存中的位置</li>
<li>需要右值的地方可以用左值（也使用对象的内容）；需要左值的地方不能用右值</li>
<li>使用decltype时，若表达式结果是左值，得到一个引用类型</li>
</ul>
</li>
</ul>
</li>
<li>优先级与结合律<ul>
<li>复合表达式：含有两个或多个运算符的表达式。优先级和结合律决定了运算对象组合的方式，括号无视上述规则。</li>
<li>高优先级运算符的运算对象比低优先级更紧密地结合在一起。</li>
<li>若运算符的优先级相同，将按照从左向右的顺序组合运算对象。</li>
</ul>
</li>
<li>求值顺序<ul>
<li>若运算符没有指定执行顺序，若表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</li>
<li>4种运算符规定了求值顺序：逻辑与 逻辑或 条件运算符?:  逗号运算符，</li>
<li>运算对象的求值顺序与优先级 结合律无关</li>
<li>处理复合表达式<ul>
<li>用括号强制让表达式的组合关系符合程序的逻辑要求</li>
<li>若改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象</li>
<li>若改变运算对象的子表达式本身 就是 另外一个子表达式的运算对象时，该规则无效。<code>*++iter</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><ul>
<li>能作用于任意算术类型（或能转换成算术类型的类型）</li>
<li>运算对象和求值结果都是右值。</li>
<li>表达式求值前，小整数类型会被提升为大整数类型，最终所有运算对象转换为同一种类型。</li>
<li>一元正号运算符、加减运算符都能作用于指针，返回运算对象的一个副本。</li>
<li>bool值不应该参与运算，会先被提升为int类型，造成相关错误。（bool值1求负号，变int型-1 转回bool 还是true）</li>
<li>溢出和其他算术运算异常<ul>
<li>除数是0 产生未定义结果</li>
<li>溢出：计算结果超出该类型能表示的范围。结果不可预知，可能环绕，即符号位溢出被修改。</li>
</ul>
</li>
<li>整数相除商还是整数，弃掉商的小数部分</li>
<li>%取余：运算对象必须是整数类型。若m%n不等于0，则符号和m相同</li>
</ul>
<h4 id="逻辑运算符和关系运算符"><a href="#逻辑运算符和关系运算符" class="headerlink" title="逻辑运算符和关系运算符"></a>逻辑运算符和关系运算符</h4><ul>
<li>逻辑运算符和关系运算符的返回值都是bool类型，运算对象和求值结果都是右值。</li>
<li>逻辑与 和 逻辑或<ul>
<li>先求左侧值，再求右侧值；</li>
<li>短路求值：左侧运算对象无法确定 表达式结果 时，才会计算右侧表达式的值</li>
</ul>
</li>
<li>基于范围的for循环中，将其中的元素声明为引用类型，可以避免对过大元素的拷贝</li>
<li>逻辑非</li>
<li>关系运算符<ul>
<li>关系运算符尽量不要连写，可以用 逻辑与 连接</li>
</ul>
</li>
<li>相等性测试与布尔字面值<ul>
<li>比较运算时，除非比较的对象是bool型，不要用bool字面值true或false作为比较对象</li>
</ul>
</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ul>
<li>赋值运算的结果是它的左侧运算对象，并且是一个左值。结果的类型是左侧运算对象的类型。</li>
<li>若左右类型不同，右侧运算对象会转为左侧对象的类型</li>
<li>C++11允许花括号括起来的初始值列表作为右侧对象<ul>
<li>初始列表为空时，编译器创建一个值初始化的临时量，赋给左侧对象。</li>
</ul>
</li>
<li>赋值运算符满足 右结合律</li>
<li>多重赋值语句：其中的每一个对象，类型与右边对象相同，或可由右边对象类型转换得到。</li>
<li>赋值运算符优先级 &lt; 关系运算符优先级，条件语句中，赋值部分加括号。</li>
<li>切勿混淆赋值运算符和相等运算符</li>
<li>复合赋值运算符：相比普通运算符（求值两次），复合运算符只求值一次。</li>
</ul>
<h4 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h4><ul>
<li><p>前置和后置</p>
<ul>
<li>前置：运算对象先加1，然后将改变后的对象作为求值结果。将对象本身作为左值返回。</li>
<li>后置：运算对象加1，求值结果是 改变前的运算对象的副本。将 对象原始值的副本 作为右值返回。</li>
<li>尽可能不用后置版本，需要存储原始值，这种操作可能是一种浪费。</li>
</ul>
</li>
<li><p>混用解引用和递增</p>
<ul>
<li><p>后置递增优先级 &gt; 解引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg=v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(pbeg!=v.<span class="built_in">end</span>() &amp;&amp; *pbeg&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; *pbeg++ &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出当前pbeg指向的值，并将指针pbeg向前移动一个位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(pbeg++) &lt;&lt;<span class="built_in">endl</span>;<span class="comment">//等价于上面一句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>赋值运算符左右两端用到了同一个运算对象并改变了值。可能出现未知错误</p>
</li>
</ul>
<h4 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h4><ul>
<li>点运算符：获取类对象的一个成员。结果和成员所属的对象一致。成员所属对象是左值，结果就是左值。</li>
<li>箭头运算符：作用于指针类型的运算对象，结果是一个左值。</li>
</ul>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><ul>
<li>把简单的if-else逻辑嵌入到单个表达式中。</li>
<li>cond ?expr1:expr2</li>
<li>首先求cond 的值，若条件为真，对expr1求值并返回，否则对expr2求值并返回。</li>
<li>嵌套条件运算符</li>
<li>条件运算符满足 右结合律</li>
<li>嵌套不宜过多</li>
<li>条件运算符优先级很低，在长表达式中通常要加括号</li>
</ul>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ul>
<li>作用于整数类型的运算对象，并把运算对象看成二进制位的集合</li>
<li>提供检查和设置二进制位的功能</li>
<li>小整型的对象值会被提升为较大的整数类型</li>
<li>处理有符号类型的结果未知（依赖机器），因此尽量处理无符号类型</li>
<li>移位运算符<ul>
<li>&lt;&lt;和&gt;&gt;：对运算对象执行基于二进制位的移动操作</li>
<li>右侧运算对象不能为负，且其值严格小于结果的位数。否则会产生未定义结果。</li>
<li>移出边界外的位数被舍弃</li>
</ul>
</li>
<li>位求反运算符<ul>
<li>char类型先提升成int型</li>
</ul>
</li>
<li>位与、位或、位异或运算符</li>
<li>移位（IO）运算符满足左结合律</li>
</ul>
<h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><ul>
<li><p>返回一条表达式或一个类型名字所占的字节数</p>
</li>
<li><p>满足右结合律</p>
</li>
<li><p>运算对象</p>
<ul>
<li>类型：返回类型大小</li>
<li>表达式结果：返回结果的类型大小,并不计算实际对象的值</li>
</ul>
</li>
<li><p>对象可以是未定义的指针，因为不计算具体值，指针并没有被真正使用</p>
</li>
<li><p>c++11允许使用作用域运算符来获取类成员的大小</p>
</li>
<li><p>sizeof运算符结果依赖于作用的类型</p>
<ul>
<li>对char执行，结果为1</li>
<li>对引用执行：得到被引用对象所占空间大小</li>
<li>对指针执行：得到指针本身所占空间大小</li>
<li>对解引用指针执行：得到指针指向对象所占空间大小，指针不需要有效。</li>
<li>对数组执行：得到整个数组所占空间大小，等价于对其中每个元素执行并求和。不会把数组转换为指针处理</li>
<li>对string或vector处理：只返回该类型固定部分的大小，不计算其中的元素占多少空间</li>
</ul>
</li>
<li><p>可以用数组大小除以单个元素大小，得到数组元素个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia) / <span class="keyword">sizeof</span>(*ia);</span><br><span class="line"><span class="keyword">int</span> arr2[sz];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h4><ul>
<li>两个运算对象，求值顺序从左到右</li>
<li><strong>首先对左侧表达式求值，然后丢弃求值结果。真正的结果是右侧表达式的值</strong></li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li>如果两种类型可以相互转换，那么它们就是关联的</li>
<li>隐式转换：自动执行类型转换，尽可能避免损失精度</li>
<li>何时发生隐式转换：<ul>
<li>比int小的整数类型提升</li>
<li>非布尔转换为布尔</li>
<li>初始化时，初始值转换为变量类型；赋值语句中，右侧对象转换为左侧对象类型</li>
<li>算术运算或关系运算的对象有多种类型，需要转换为同一种</li>
<li>函数调用时</li>
</ul>
</li>
<li>算术转换：一种算术类型转换为另一种算术类型<ul>
<li>运算符的运算对象转换为最宽的类型</li>
<li>表达式中既有浮点又有整数，整数转浮点</li>
<li>无符号运算对象：整型提升-&gt;有无符号也有带符号类型<ul>
<li>无符号类型大于带符号类型：带符号转为无符号</li>
<li>无符号类型小于带符号类型：转换结果依赖机器，看无符号的所有值能否都存在带符号类型中，能就转为带符号</li>
</ul>
</li>
<li>其他隐式类型转换<ul>
<li>数组转换为指针</li>
<li>指针的转换</li>
<li>转换为布尔类型：0-false</li>
<li>转换成常量：将指向非常量类型的指针转换为指向相应常量的指针</li>
<li>类类型定义的转换：</li>
</ul>
</li>
</ul>
</li>
<li>显式转换<ul>
<li>强制类型转换</li>
<li>cast-name&lt; type &gt;(expression):cast-name指定执行哪一种转换，type是转换的目标类型，expression是待转换的值</li>
<li>执行哪一种转换<ul>
<li>static_cast：不包含底层const就可以用，较大的算数类型赋值给较小的类型；编译器无法自动执行的类型转换</li>
<li>const_cast：只能改变运算对象的底层const，常量转非常量（去const），对象只能改变常量属性</li>
<li>reinterpret_cast：为运算对象的位模式提供较低层次的重新解释。如改int指针为char指针，但所指还是int型对象。很可能在运行时引发错误</li>
<li>dynamic_cast</li>
</ul>
</li>
<li>避免强制类型转换</li>
<li>旧式的强制类型转换：表现形式不那么清晰</li>
</ul>
</li>
</ul>
<h4 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h4><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>对于超过一个运算符的表达式，理解其含义需要关键要理解优先级、结合律和求值顺序</li>
<li>大多数运算符并不明确规定运算对象的求值顺序：编译器有权自由选择先对左侧或右侧运算对象求值；如果两个运算对象指向同一个对象，且其中一个改变了对象的值，就会导致程序的严重缺陷</li>
<li>运算对象经常从原始类型自动转换成某种关联的类型，若需要的话，也可以进行显式的类型转换</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>算术转换</li>
<li>隐式转换</li>
<li>整型提升</li>
<li>短路求值</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第二章</title>
    <url>/2020/07/13/c-primer-2/</url>
    <content><![CDATA[<h3 id="第I部分-C-基础-（第2章-第7章）"><a href="#第I部分-C-基础-（第2章-第7章）" class="headerlink" title="第I部分 C++基础 （第2章-第7章）"></a>第I部分 C++基础 （第2章-第7章）</h3><h3 id="第2章-变量和基本类型"><a href="#第2章-变量和基本类型" class="headerlink" title="第2章 变量和基本类型"></a>第2章 变量和基本类型</h3><p>本章主要讲述内置类型，以及c++如何支持更复杂的数据类型。</p>
<a id="more"></a>

<ul>
<li>任何编程语言都具备一组公共的语法特征。最基本的特征包括：<ul>
<li>整形、字符型等<strong>内置类型</strong></li>
<li><strong>变量</strong>，为对象命名</li>
<li><strong>表达式和语句</strong>，操纵上述类型的具体值</li>
<li><strong>控制结构</strong>，控制语句执行</li>
<li><strong>函数</strong>，定义可随时调用的计算单元</li>
</ul>
</li>
<li>大多数编程语言通过两种方式进一步补充基本特征：<ul>
<li>程序员自定义数据类型</li>
<li>将有用的功能封装成库函数</li>
</ul>
</li>
<li>C++的对象类型决定对它进行的操作。</li>
<li>C++是一种静态数据类型语言，编译时进行类型检查。编译器要知道每个变量对应的数据类型。</li>
<li>简单的编程语言，强大的<strong>数据结构自定义</strong></li>
<li>最重要的语法特征是 <strong>类class</strong> ，允许新类型包含数据和函数成员</li>
</ul>
<h4 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h4><ul>
<li><p>包括<strong>算术类型</strong>和<strong>空类型</strong></p>
</li>
<li><p>算术类型</p>
<ul>
<li>整型：包括字符和布尔类型</li>
<li>浮点型</li>
</ul>
</li>
<li><p>一个char型的大小和一个机器字节一样（8bit=1byte）</p>
</li>
<li><p>short16–int16–long32–long long64</p>
</li>
<li><p><strong>内置类型的机器实现</strong></p>
<ul>
<li>计算机以比特序列存储数据。可寻址的最小内存块为 <strong>字节byte</strong>，存储的基本单元称为 <strong>字word</strong> 。1word=4 or 8 byte = 32 or 64 bit</li>
<li>一个字节对应一个地址</li>
<li>一个字或字节的首位（bit）地址即表示这个字或字节的地址</li>
<li>如果一个对象类型是32位，计算机一个字有4个字节，那么用4个字节/1个字存储这个对象</li>
</ul>
</li>
<li><p>float单精度 6位有效数字 32位–double双精度 10位有效数字 64位–long double扩展精度 10位有效数字 96or128位</p>
</li>
<li><p>带符号和无符号类型</p>
<ul>
<li>带符号：正数 负数 0 int short long longlong。标识范围内正值和负值的量应该平衡。如8bit的char为-128-127</li>
<li>无符号：大于等于0的值 添加unsigned即无符号 如unsigned long。所有比特都用来存储值。</li>
<li>字符型分为三种：char 、signed char、unsigned char。但表现形式仍为两种：带符号、无符号。char表现为二者之一，由编译器决定</li>
</ul>
</li>
<li><p>如何选择类型</p>
<ul>
<li>数值不可能为负–使用无符号</li>
<li>整数运算用int，若超过范围使用longlong</li>
<li>算术表达式中不用char或bool</li>
<li>浮点数运算用double</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li>赋给无符号类型超出范围的值：初始值 对 无符号表示数值的总数 取模的余数，如下c=255.</li>
<li>赋给带符号类型超出范围的值：结果是未定义的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b=<span class="number">42</span>;					<span class="comment">//b=true</span></span><br><span class="line"><span class="keyword">int</span> i=b;  					<span class="comment">//i=1</span></span><br><span class="line">i=<span class="number">3.14</span>;						<span class="comment">//i=3</span></span><br><span class="line"><span class="keyword">double</span> pi=i;				<span class="comment">//pi=3.0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c=<span class="number">-1</span>;			<span class="comment">//c=255  0-255区间 -1对256取模得到的余数（取模操作结果为正数） （-1 mod 256=（-1+256）mod 256=255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2=<span class="number">256</span>;			<span class="comment">//c2为未定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>避免无法预知和依赖于实现环境的行为</p>
<ul>
<li>无法预知：编译器无法检测</li>
<li>依赖于实现环境：如把int的尺寸看做确定不变的尺寸值，则程序 <strong>不可移植</strong></li>
</ul>
</li>
<li><p>bool值在算术表达式中非0即1，因此不宜在算术表达式中用bool。</p>
</li>
<li><p>含有无符号类型的表达式–例1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">-42</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; i + i &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//输出-84  （-42）+（-42）=-84</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若int占32位，输出4294967264，相加前把i（-42）转换为无符号数</span></span><br><span class="line"><span class="comment">//（-42）mod（2^32）=（2^32-42）mod（2^32）=2^32-42=4294967296-42=4294967254,也就是i转换后的值</span></span><br><span class="line"><span class="comment">//计算i+u，4294967254+10=4294967264，输出结果。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u + i &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>含有无符号类型的表达式–例2</p>
<ul>
<li>从无符号数中减去一个值时，不管这个值是不是无符号数，都必须确保结果不能是负值。否则结果为取模后的值，如下。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u1=<span class="number">42</span>,u2=<span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u1 - u2 &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//输出32 正确</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u2 - u1 &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//正确，但输出取模后的值 4294967264  </span></span><br><span class="line"><span class="comment">//10-42=（-32），（-32）mod（2^32）=（2^32-32）mod（2^32）=（2^32-32）= 4294967264</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无符号数+循环控制</p>
<ul>
<li><p>常使用while代替for，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> u=<span class="number">10</span>;u&gt;=<span class="number">0</span>;--u)</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出0后，执行--u。此时u=-1，转换为无符号数（取模），u=4294967295，陷入死循环。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法，使用while循环，同样输出10到0，避免执行 u取0时再减1。</span></span><br><span class="line"><span class="keyword">unsigned</span> u=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">while</span>(u&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	--u;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>切忌混用带符号类型和无符号类型，带符号数会自动转换为无符号数，出现异常结果。</p>
</li>
<li><p>字面值常量：形式和值决定它的数据类型</p>
</li>
<li><p>整型字面值：类型默认为容纳其数值的 <strong>尺寸最小的类型</strong>。 <strong>short类型没有对应的字面值。</strong></p>
<ul>
<li>八进制：0开头</li>
<li>十六进制：0x或0X开头</li>
<li>十进制：正常表示。十进制字面值不会是负数，形如-42，负号并不属于字面值，仅对字面值取负值。</li>
</ul>
</li>
<li><p>浮点型字面值默认为double</p>
</li>
<li><p>char型字面值：单引号包括</p>
</li>
<li><p>字符串型字面值:双引号包括。编译器在结尾加一个空字符（‘\0’)，字面值实际长度比内容多1。</p>
<ul>
<li><p>若字符串字面值紧邻，仅由空格、缩进、换行符分隔，则为一个整体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"aaaaaa"</span></span><br><span class="line">		<span class="string">"bbbb"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出一行字符串“aaaaaabbbb”</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>转义序列：两类字符不能直接使用，需要使用转义序列。以反斜线作为开始，被当做一个字符使用</p>
<ul>
<li>不可打印字符：退格等，无可视的图符</li>
<li>有特殊含义的字符：单双引号、问号、反斜线…</li>
</ul>
</li>
<li><p>泛化转义序列：\x后加十六进制数，或\后跟1、2或3个八进制数字。数字部分表示字符对应数值。</p>
<ul>
<li>若反斜线后跟超过3个八进制数字，只有前三个与\构成转义序列</li>
<li>\x后可以跟任意个十六进制数字</li>
</ul>
</li>
<li><p>指定字面值类型</p>
<ul>
<li>添加前缀和后缀，可以改变整型、浮点型、字符型字面值的默认类型。</li>
<li>长整型建议使用大写L标记。</li>
<li>字符和字符串用前缀指定；整型和浮点型用后缀指定。</li>
</ul>
</li>
<li><p>布尔字面值：true、false</p>
</li>
<li><p>指针字面值：nullptr</p>
</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li><p>变量提供一个具名的、可供程序操作的存储空间。</p>
</li>
<li><p>变量的数据类型决定内存大小、布局方式、存储值的范围、能参与的运算。</p>
</li>
<li><p>变量定义：类型说明符+一个或多个变量名的列表。</p>
</li>
<li><p>什么是<strong>对象</strong>？</p>
<ul>
<li>一块能<strong>存储数据</strong>并具有某种<strong>类型</strong>的<strong>内存空间</strong>。</li>
</ul>
</li>
<li><p>初始化：对象在创建时获得一个特定的值。</p>
<ul>
<li><p>同一定义语句中，可以用先定义的变量值 初始化 后定义的其他变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> price=<span class="number">109.99</span>,discount=price*<span class="number">0.16</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>初始化不是赋值！</strong></p>
<ul>
<li>初始化在创建变量是赋予一个初始值</li>
<li>赋值把对象的当前值擦除，再用一个新值替代。</li>
</ul>
</li>
<li><p>列表初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//四种初始化语句</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//列表初始化</span></span><br><span class="line"><span class="keyword">int</span> a=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>若使用列表初始化，且初始值存在丢失的风险，则编译器会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> ld=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;ld&#125;,b=&#123;ld&#125;;<span class="comment">//使用列表初始化 编译器报错：转换未执行，存在丢失信息的风险。</span></span><br><span class="line"><span class="keyword">int</span> c&#123;ld&#125;,d=ld;<span class="comment">//不使用列表初始化 通过编译：转换执行，确实丢失了部分值。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>默认初始化</p>
<ul>
<li>定义变量时未指定初值，则默认初始化，变量被赋予默认值。</li>
<li>默认值由变量类型决定，定义变量的位置也有影响。</li>
<li>定义于函数体之外的变量被初始化为0.</li>
<li>定义在函数体内部的变量不被初始化，它的值是未定义的。若访问此类值将出错。</li>
<li>每个类决定其初始化对象的方式，以及能否不经初始化就定义对象。</li>
<li>绝大多数类 无须显示初始化 来定义对象，提供一个合适的默认值。如string类（未指定初值，则生成一个空串</li>
<li>一些类要求每个对象进行显式初始化，否则报错。</li>
</ul>
</li>
<li><p>未初始化变量会引发运行时故障</p>
<ul>
<li>建议初始化每一个内置类型的变量，确保初始化后程序安全。</li>
</ul>
</li>
<li><p>分离式编译</p>
<ul>
<li>允许将程序分割成若干个文件，每个文件独立编译。</li>
</ul>
</li>
<li><p>变量的声明和定义</p>
<ul>
<li><p>声明：名字被程序所知，文件要使用别处定义的名字，必须包含对那个名字的声明。</p>
</li>
<li><p>定义：创建与名字关联的实体。为变量申请空间，可能赋初值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;	<span class="comment">//只声明i，并未定义i</span></span><br><span class="line"><span class="keyword">int</span> j;			<span class="comment">//声明i，并且定义i</span></span><br><span class="line"><span class="comment">//extern语句若包含初始值，则变成定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi=<span class="number">3.1415</span>;<span class="comment">//定义pi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明+赋初始值=定义</p>
</li>
<li><p>函数体内部，若初始化一个extern标记的变量，会报错。</p>
</li>
<li><p>变量能且只能被定义一次，但可以被多次声明。</p>
</li>
</ul>
</li>
<li><p>多个文件使用同一个变量</p>
<ul>
<li>变量定义只能出现在一个文件中</li>
<li>其他用到该变量的文件要对其声明，但不能重复定义。</li>
</ul>
</li>
<li><p>静态类型：在编译阶段 检查类型（类型检查）</p>
<ul>
<li>C++是静态类型语言</li>
<li>编译器检查数据类型是否支持要执行的运算，不支持则报错，不生成可执行文件</li>
<li>使用变量前必须声明某个类型，以便编译器进行检查。</li>
</ul>
</li>
<li><p>标识符</p>
<ul>
<li>必须以字母或下划线开头</li>
<li>对大小写字母敏感</li>
<li>不能使用标准库关键字</li>
<li>不能连续出现两个下划线，也不能下划线紧连大写字母开头。</li>
<li>函数体外的标识符不能以下划线开头。</li>
</ul>
</li>
<li><p>变量命名规范</p>
<ul>
<li>一般用小写字母</li>
<li>自定义类名一般大写字母开头</li>
<li>若标识符由多个单词组成，由大写字母或下划线分割</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li><p>多数作用域用大括号分隔</p>
</li>
<li><p>同一个名字在不同的作用域中可能指向不同的实体</p>
</li>
<li><p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> val=<span class="number">1</span>;val&lt;=<span class="number">10</span>;++val)</span><br><span class="line">		sum+=val;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"Sum of 1 to 10 inclusive is"</span></span><br><span class="line">		     &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了3个名字 main、sum、val，并使用了命名空间名字std，该空间提供了两个名字cout、cin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>全局作用域：main。声明后在整个程序内都可使用。</p>
</li>
<li><p>块作用域：sum。声明后到函数结束为止都可使用。</p>
</li>
<li><p>名字val仅可在for循环内访问。</p>
</li>
</ul>
</li>
<li><p>在第一次使用变量时再定义它，更容易找到定义和赋初值。</p>
</li>
<li><p>嵌套的作用域 （外层作用域（内层作用域））</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> reused=<span class="number">42</span>;					<span class="comment">//全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> unique=<span class="number">0</span>;				<span class="comment">//unique拥有块作用域</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//输出全局变量reused=42</span></span><br><span class="line">	<span class="keyword">int</span> reused=<span class="number">0</span>;				<span class="comment">//定义局部变量reused，覆盖了全局变量</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;reused&lt;&lt;<span class="built_in">endl</span>;			<span class="comment">//输出局部变量reused=0</span></span><br><span class="line">    <span class="comment">//使用作用域操作符 :: ，覆盖默认的作用域规则。操作符左侧为空，默认使用全局作用域中的右侧变量。</span></span><br><span class="line">    <span class="comment">//显示访问全局变量reused，输出reused=42</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;::reused&lt;&lt;<span class="built_in">endl</span>;		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要定义和全局变量同名的局部变量。</p>
</li>
</ul>
<h4 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h4><p>基于其他类型定义的类型。</p>
<ul>
<li><p>声明语句：由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名了一个变量，并指定其为 与基本数据类型相关的类型。</p>
</li>
<li><p>引用（左值引用</p>
<ul>
<li><p>引用类型 引用 另外一种类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival=<span class="number">1024</span>;		<span class="comment">//定义int型变量ival，初始化为1024</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal=ival;	<span class="comment">//定义引用类型的变量refVal，指向ival（refVal是ival的另一个名字</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal2;		<span class="comment">//报错：引用必须被初始化</span></span><br><span class="line">refVal=<span class="number">2</span>;			<span class="comment">//即把2赋值给了ival</span></span><br><span class="line"><span class="keyword">int</span> ii=refVal;		<span class="comment">//ii初始化为ival的值</span></span><br><span class="line"><span class="keyword">int</span> &amp;refVal3=refVal;<span class="comment">//refVal3绑定到了ival上</span></span><br><span class="line"><span class="keyword">int</span> i=refVal;		<span class="comment">//i被初始化为ival的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化后，引用会和它的初始值对象一直 绑定bind 在一起。   <strong>引用必须初始化</strong></p>
</li>
<li><p>引用不是对象，它是一个已有对象的另一个名字</p>
</li>
<li><p>无法定义引用的引用，因为引用不是对象，只能定义一个对象的引用。</p>
</li>
<li><p>除了两种例外情况，引用的类型与绑定对象严格匹配。</p>
</li>
<li><p><strong>非常量引用只能绑定在对象上，不能是字面值或计算结果。</strong></p>
</li>
<li><p>定义引用后，每次使用引用都会访问它 最初绑定的那个对象。</p>
</li>
</ul>
</li>
<li><p>指针：指向 另外一种类型 的 复合类型。</p>
<ul>
<li><p>与引用的不同：</p>
<ul>
<li>指针本身就是对象，允许赋值拷贝，且声明周期内可以先后指向不同的对象</li>
<li>指针定义时不需要赋初值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1,*p2;		<span class="comment">//定义指针p1，p2，指向int型对象</span></span><br><span class="line"><span class="keyword">double</span> dp,*dp2;		<span class="comment">//定义double型dp，指向double型对象的指针dp2</span></span><br><span class="line"><span class="keyword">int</span> ival=<span class="number">42</span>;		</span><br><span class="line"><span class="keyword">int</span> *p=&amp;ival;		<span class="comment">//p存放ival的地址，p是指向ival的指针</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p;			<span class="comment">//使用解引用符访问ival，输出42</span></span><br><span class="line">*p=<span class="number">0</span>;				<span class="comment">//使用解引用符，给ival赋值0</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*p;			<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针存放某个对象的地址</p>
</li>
<li><p>除两种例外情况，指针类型要和指向的对象严格匹配</p>
</li>
</ul>
</li>
<li><p>指针值：属于以下四种状态之一</p>
<ul>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置–不允许访问</li>
<li>空指针，未指向任何对象–不允许访问</li>
<li>无效指针，上述情况外的其他值</li>
</ul>
</li>
<li><p>访问无效指针的值会报错，和使用未初始化的变量一样。</p>
</li>
<li><p>利用指针访问对象：使用解引用符（*)</p>
<ul>
<li>仅适用于确实指向某个对象的指针</li>
</ul>
</li>
<li><p>某些符号的多重含义</p>
<ul>
<li>&amp; ：引用声明的一部分 / 取地址符</li>
<li>* :指针声明的一部分 / 解引用符</li>
</ul>
</li>
<li><p>空指针：不指向任何对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">//生成空指针p1,p2,p3</span></span><br><span class="line"><span class="keyword">int</span> *p1=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3=<span class="literal">NULL</span>;<span class="comment">//预处理变量NULL，在 cstdlib中定义 即0.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>预处理器：运行于编译之前的一段程序。预处理变量由预处理器负责管理（自动将它替换为实际值</li>
</ul>
</li>
<li><p>不能把int变量直接赋值给指针</p>
</li>
<li><p>初始化所有的指针，尽可能在定义对象后 再定义指向它的指针。或者初始化为nullptr或0.</p>
</li>
<li><p>给指针赋值就是给它一个新的地址，指向一个新的对象。</p>
</li>
<li><p>赋值永远改变的是等号左侧的对象。</p>
</li>
<li><p>任何非0指针对应的条件都是true。</p>
</li>
<li><p>比较指针的前提是都为合法指针。两个指针存放的地址相同（指针相等）有三种可能：</p>
<ul>
<li>都为空</li>
<li>都指向同一个对象</li>
<li>都指向同一个对象的下一个地址</li>
<li>一个指针指向某对象，另一个指针指向另外对象的下一个地址</li>
</ul>
</li>
<li><p>void*：特殊的指针类型，存放任意对象的地址</p>
<ul>
<li>仅指向一块内存空间，无法访问内存空间中的对象。</li>
</ul>
</li>
<li><p>指针或引用的两种写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修饰符和类型名写在一起，每条语句只定义一个变量。</span></span><br><span class="line"><span class="keyword">int</span>* p1;</span><br><span class="line"><span class="keyword">int</span>* p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修饰符和变量标识符写在一起</span></span><br><span class="line"><span class="keyword">int</span> *p1,*p2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指向指针的指针</p>
<ul>
<li>使用 * 的个数区分指针的级别，如 ** 表示指向指针的指针。。。</li>
<li>解引用 int型指针 会得到一个int型的数。解引用 指向指针的指针 会得到一个指针，再解引用 就可以得到最原始的对象。</li>
</ul>
</li>
<li><p>指向指针的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;		</span><br><span class="line"><span class="keyword">int</span> *p;			<span class="comment">//int型指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r=p;		<span class="comment">//r是对指针p的引用，从右向左看，首先r是一个引用，* 说明r引用的是一个指针，是int型的指针。</span></span><br><span class="line"></span><br><span class="line">r=&amp;i;			<span class="comment">//p指针指向i</span></span><br><span class="line">*r=<span class="number">0</span>;			<span class="comment">//i赋值为0</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h4><p>定义一种变量（常量） ，使它的值不能被改变</p>
<ul>
<li><p>const对象必须初始化</p>
</li>
<li><p>只能读const对象执行不改变内容的操作</p>
</li>
<li><p><strong>？</strong>const对象的常量特征 仅在改变该对象时才会发挥作用</p>
</li>
<li><p>const对象仅在文件内有效</p>
</li>
<li><p>编译器会把与const同名的变量都替换成对应的const值</p>
</li>
<li><p>只在一个文件中定义const，在其他多个文件中声明并使用它</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file1.cc文件中定义并初始化一个常量，能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize=fcn();</span><br><span class="line"><span class="comment">//file1.h文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;<span class="comment">//定义了同一个bufSize</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多个文件共享const对象，在定义之前添加extern关键字</p>
</li>
<li><p>对常量的引用</p>
<ul>
<li>引用也必须是常量类型</li>
<li><strong>无法通过常量引用修改绑定对象的值</strong></li>
<li>对const的引用可以简称为 常量引用</li>
</ul>
</li>
<li><p><strong>允许为一个 常量引用 绑定 非常量的对象、字面值或一般表达式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=i;		<span class="comment">//允许将const int&amp; 绑定到int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2=<span class="number">42</span>;		<span class="comment">//允许 r2是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3= r1 * <span class="number">2</span>;	<span class="comment">//允许 r3是一个常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4=r1*<span class="number">2</span>;			<span class="comment">//错误 r4是一个非常量引用,右边是一个字面值，非常量引用无法绑定字面值。</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用绑定到非常量对象上</span></span><br><span class="line"><span class="keyword">double</span> dval=<span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=dval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了确保让ri绑定一个整数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp =dval;	<span class="comment">//由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri=temp;		<span class="comment">//ri绑定这个临时量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>临时量对象：如上temp，编译器需要一个空间来暂存表达式的求值结果，临时创建了一个未命名的对象。</p>
</li>
<li><p><strong>常量引用的绑定对象若为非常量</strong></p>
<ul>
<li><strong>无法通过常量引用改变绑定对象的值</strong></li>
<li><strong>可以通过直接赋值 或 绑定到非常量引用上，来更改常量引用绑定的对象的值。</strong></li>
</ul>
</li>
<li><p>指向常量的指针</p>
<ul>
<li>不能用于改变其所指对象的值</li>
<li>用于存放常量对象的地址</li>
<li><strong>可以指向非常量对象</strong><ul>
<li><strong>此时不能通过该指针修改非常量对象的值</strong></li>
<li>可以通过别的方法直接修改非常量对象的值</li>
</ul>
</li>
</ul>
</li>
<li><p>常量指针：指针是对象，因此可以是常量。（引用不是对象，没有本身是常量的引用！</p>
<ul>
<li><p>必须初始化，初始化后其值不再改变</p>
</li>
<li><p>不变的是指针本身的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> err=<span class="number">0</span>;						</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr=&amp;err;				<span class="comment">//curErr是常量指针，一直指向err</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14159</span>;			</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip=&amp;pi;		<span class="comment">//从右往左看，pip是常量指针 pip是指向double的常量指针 pip是指向double常量的常量指针。</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如上，pip是指向常量对象的常量指针，因此pip的地址和pip指向的对象值都不能改变。</p>
</li>
<li><p>curErr是指向一般int对象的常量指针，curErr的地址不能改变，但可以用curErr改变指向对象的值。</p>
</li>
</ul>
</li>
<li><p>顶层const：表示指针本身是常量；可以表示任意的对象是常量</p>
</li>
<li><p>底层const：表示指针所指的对象是常量；表示 指针和引用 等复合类型中的 基本类型部分（指针指向  引用绑定。。）</p>
</li>
<li><p>指针类型可以是顶层const，也可以是底层const（指针的指针</p>
</li>
<li><p>声明引用的const都是底层const（引用本身不是对象，不可能是常量，不可能有顶层const</p>
</li>
<li><p><strong>执行对象的拷贝</strong></p>
<ul>
<li>顶层const不受影响</li>
<li>底层const：<strong>拷入和拷出的对象必须具有相同的底层const，或两个对象的数据类型可以转换。</strong></li>
</ul>
</li>
<li><p>常量表达式：<strong>值不会改变</strong>，并且<strong>在编译过程就能得到计算结果</strong>的表达式。</p>
<ul>
<li>字面值是常量表达式</li>
<li>常量表达式初始化的常量对象 也是 常量表达式</li>
</ul>
</li>
<li><p>constexpr变量</p>
<ul>
<li>变量可声明为该类型，由编译器验证变量的值是否是常量表达式</li>
<li>constexpr变量 一定是 一个常量，且必须用常量表达式初始化。</li>
<li>如果你认定变量是一个常量表达式，就声明为constexpr类型。</li>
</ul>
</li>
<li><p>字面值类型</p>
<ul>
<li>算术类型、引用、指针都是字面值类型</li>
<li>声明constexpr的类型必须用字面值类型</li>
</ul>
</li>
<li><p>constexpr指针</p>
<ul>
<li><strong>一个constexpr的指针初始值必须为nullptr，0，或存储在固定地址中的对象</strong></li>
<li>函数体内的变量一般不存放在固定地址中，constexpr指针不能指向这样的变量；函数体外的对象地址固定，可用于初始化这种指针。</li>
<li>constexpr仅对指针有效，与其所指的对象无关</li>
<li>constexpr指针可以指向常量 或 非常量</li>
</ul>
</li>
</ul>
<h4 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h4><ul>
<li><p>类型别名</p>
<ul>
<li><p>使用typedef定义类型别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用 别名声明 定义类型的别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> A=<span class="keyword">double</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复合类型使用别名的混淆例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr=<span class="number">0</span>;<span class="comment">//cstr是指向char的常量指针！  并不是指向常量char的指针！</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;	<span class="comment">//ps是一个指针，指向 指向char的常量指针。</span></span><br><span class="line"><span class="comment">//const修饰pstring，因此 const pstring 代表指向char的常量指针</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>auto类型说明符</p>
<ul>
<li><p>由编译器通过初始值分析表达式的类型</p>
</li>
<li><p>auto定义的变量必须有初始值</p>
</li>
<li><p>auto也能在一条语句中声明多个变量，但这些变量的基本类型必须相同。</p>
</li>
<li><p>引用：编译器以引用对象的类型作为auto的类型</p>
</li>
<li><p>auto忽略顶层const，保留底层const；若希望auto是顶层const，可以手动添加： const auto…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;h=<span class="number">42</span>;				<span class="comment">//报错，auto被判为非常量引用，不能绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;h=<span class="number">42</span>;		<span class="comment">//正确，常量引用可以绑定字面值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=i;</span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci, *p = &amp;ci;	<span class="comment">//ok 两个都是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i,*p2 = &amp;ci;	<span class="comment">//报错 前一个是int 后一个是const int（p2是指向常量的指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>decltype类型指示符</p>
<p>选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，但不实际计算表达式的值。</p>
<ul>
<li><p>若decltype使用的表达式是一个变量，则返回的类型包括顶层const和<strong>引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cj=ci;</span><br><span class="line"><span class="keyword">decltype</span>(cj) z;<span class="comment">//注意这里，不能直接把cj换成ci理解，decltype根据cj判断：返回的类型是引用，因此z是一个引用，z未被初始化，报错。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若decltype使用的表达式不是变量，返回 表达式结果对应的类型。</p>
<ul>
<li><p>表达式内容是解引用，decltype得到引用类型</p>
</li>
<li><p>表达式若为加上括号的变量，结果是引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>((variable)) <span class="comment">//结果是引用</span></span><br><span class="line"><span class="keyword">decltype</span>(variable)   <span class="comment">//只有Variable是引用，结果才会是引用</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h4><ul>
<li><p>最基本层面： <strong>数据结构</strong>–把一组相关的数据元素组织起来，然后使用它们的 <strong>策略和方法</strong>。</p>
</li>
<li><p>允许用户以类的形式自定义数据类型</p>
</li>
<li><p>类定义的最后加上分号。</p>
</li>
<li><p>类数据成员</p>
<ul>
<li>类的每个对象有自己的一份数据拷贝。</li>
<li>c++11 可以为类的数据成员提供一个类内初始值，用于初始化数据成员，否则默认初始化。</li>
</ul>
</li>
<li><p>编写头文件</p>
<ul>
<li>类通常被定义在头文件中</li>
<li>头文件通常包含 只能被定义一次的实体</li>
<li>头文件经常用到其他头文件的功能</li>
<li>头文件概念–相关源文件要重新编译，获取更新过的声明</li>
</ul>
</li>
<li><p>预处理器</p>
<p>编译之前执行的一段程序</p>
<ul>
<li><p>如#include，预处理器会用指定的头文件内容代替#include</p>
</li>
<li><p><strong>头文件保护符：防止重复包含</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H				<span class="comment">//检查预处理变量是否已定义，ifndef--未定义时为真</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H				<span class="comment">//将一个名字设为预处理变量 此时已定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如上，第一次包含时，ifndef检查结果为真，程序执行到endif，此时预处理变量SALES_DATA_H变为已定义，头文件也被拷贝到程序中；之后若重复包含该头文件，#ifndef检查结果为假，编译器忽略 #ifndef 到 #endif 的部分。</p>
</li>
<li><p>整个程序中的预处理变量必须唯一，包括头文件保护符。基于头文件中类的名字构建保护符的名字，确保其唯一性。</p>
</li>
<li><p>预处理变量名字一般大写（避免名字冲突</p>
</li>
<li><p>头文件最好设置保护符。</p>
</li>
</ul>
</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>默认初始化<ul>
<li>全局作用域：初始化为0</li>
<li>局部作用域：未定义的值</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第三章</title>
    <url>/2020/07/15/c-primer-3/</url>
    <content><![CDATA[<h3 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h3><p>c++的抽象数据类型库中，string和vector是两种最重要的标准库类型，前者支持可变长字符串；后者支持可变长的集合。还有一种标准类型是迭代器，是string和vector的配套类型。</p>
<p>本章将分别介绍数组以及标准库类型string和vector。</p>
<a id="more"></a>

<h4 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>每个名字需要独立的using声明</li>
<li>头文件中不应使用using声明</li>
</ul>
<h4 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义和初始化string对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//字符c重复10次 即cccccccccc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接初始化（不使用等号）和拷贝初始化（使用等号）</p>
</li>
<li><p>string对象上的操作</p>
<ul>
<li><p>读取时，string自动忽略开头的空白，从第一个真正的字符开始读起，直到遇见下一处空白。</p>
</li>
<li><p>读取未知数量的string对象：while(cin&gt;&gt;word){…}. 流有效则循环读取。</p>
</li>
<li><p>使用getline读取一整行（包括空白符。getline返回 流参数。<strong>首先从输入流中读入内容（包括换行符），之后存入string对象（不存换行符）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">	<span class="keyword">while</span>(getline(<span class="built_in">cin</span>,<span class="built_in">line</span>))	<span class="comment">//每次读一整行，直到文件末尾</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">line</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>empty函数，根据string对象是否为空返回bool值。<code>line.empty()</code> </p>
</li>
<li><p>size函数返回长度（string对象中字符个数）<code>line.size()</code>，返回<strong>string::size_type类型</strong>的值，<strong>无符号类型</strong>。不要在表达式中和带符号类型混用（会自动转换）</p>
</li>
<li><p>比较string对象：对大小写敏感。长度相等比字典序，否则比长度。</p>
</li>
<li><p>string对象赋值：等号</p>
</li>
<li><p>相加：两个string串接</p>
<ul>
<li><p>和字面值相加：必须确保每个 + 两侧的对象至少有一个是string</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s6=s1+<span class="string">","</span>+<span class="string">"world"</span>;<span class="comment">//ok，等价于下一行</span></span><br><span class="line"><span class="built_in">string</span> s6=(s1+<span class="string">","</span>)+<span class="string">"world"</span>;<span class="comment">//每个加号两侧都至少有一个string</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符串字面值与string是 <strong>不同的类型</strong></p>
</li>
</ul>
</li>
<li><p>处理string对象中的字符</p>
<ul>
<li>cctype头文件</li>
</ul>
</li>
<li><p>C++版本的c标准库头文件</p>
<ul>
<li>c语言头文件形如name.h  c++将这些文件命名为cname，去掉了h后缀。</li>
<li>在cname头文件中定义的名字属于命名空间std，.h头文件中的不属于。</li>
<li>C++程序应使用cname的头文件，名字总在命名空间std中，更方便。</li>
</ul>
</li>
<li><p>基于范围的for语句–处理字符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"aaaaaa"</span>)</span></span>;</span><br><span class="line"><span class="comment">//每行输出str的一个字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围for–改变字符串中的字符</p>
<ul>
<li><p>必须把循环变量定义为引用类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">&#123;</span><br><span class="line">	c=<span class="string">'a'</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际上改变了引用绑定的 字符串中实际字符的值</p>
</li>
</ul>
</li>
<li><p>访问string的单个字符</p>
<ul>
<li>使用下标<ul>
<li>从0计起</li>
<li>检查下标的合法性</li>
</ul>
</li>
<li>使用迭代器<ul>
<li>之后介绍….</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑 与 （&amp;&amp;）</p>
<ul>
<li>左侧运算对象为真时，再检查右侧运算对象</li>
</ul>
</li>
</ul>
<h4 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h4><ul>
<li><p>vector表示对象的集合，其中所有对象的类型都相同。每个对象有一个与之对应的索引</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="built_in">vector</span>&lt;Sales_item&gt; Sales_vec;	<span class="comment">//包含类的vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;	<span class="comment">//vector对象的vector</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>vector是一个类模板</p>
<ul>
<li>模板可以看作 编译器生成类或函数编写的一份说明</li>
<li>实例化：编译器根据模板创建类或函数</li>
<li>提供额外信息指定模板到底实例化成什么样的类</li>
</ul>
</li>
<li><p>vector不是类型（是模板</p>
</li>
<li><p>vector不能包含引用（引用不是对象</p>
</li>
<li><p>定义和初始化</p>
<ul>
<li>默认初始化一个vector，创建一个空vector</li>
<li>拷贝指定初始值，类型要相同</li>
<li>列表初始化 用大括号{}</li>
</ul>
</li>
<li><p><strong>三种初始化的特点</strong></p>
<ul>
<li>拷贝初始化（=）：只能提供一个初始值</li>
<li>类内初始值只能使用 拷贝初始化 或 花括号初始化</li>
<li>初始元素值的列表，只能放在花括号里{} 进行列表初始化。</li>
</ul>
</li>
<li><p>创建指定数量的vector元素</p>
</li>
<li><p>值初始化：只提供元素数量而略去初始值。此时会创建 值初始化 的元素初值。</p>
<ul>
<li>初值由元素类型决定</li>
<li>若有些 类 类型的元素必须明确提供初值，则必须提供元素初值</li>
<li>若只提供元素数量，则只能使用 直接初始化。</li>
<li>使用圆括号和花括号区分初始化<ul>
<li>圆括号：提供的值用于构造vector（容量、元素初值….）</li>
<li>花括号：列表初始化vector，括号内的值与元素类型匹配；若括号中的值不能列表初始化，则考虑构造vector</li>
</ul>
</li>
</ul>
</li>
<li><p>向vector对象中添加元素</p>
<ul>
<li>push_back：将一个值压到vector的尾端</li>
<li>vector对象能高效增长，不需要先设定大小。先定义空vector，再加入具体值。</li>
<li>不能用for循环向vector添加元素。for语句体内不应改变其遍历序列的大小。</li>
</ul>
</li>
<li><p>其他vector操作</p>
<ul>
<li>for语句修改所有元素（若赋值需要用引用类型）</li>
<li>两个vector比较 依据字典序。前提是vector中元素的值可比较。</li>
<li>计算vector对象的索引，确认下标在合理范围内</li>
<li>不能用下标形式添加vector元素，要用push_back</li>
<li>只能对确定已存在的元素执行下标操作，否则会出现 缓冲区溢出  的错误。 尽可能使用for语句确保下标合法。</li>
</ul>
</li>
</ul>
<h4 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h4><p>所有标准库容器都可以使用迭代器，但只有少部分也支持下标。</p>
<p>迭代器也提供了对 对象 的间接访问。</p>
<p>有效的迭代器：指向某个元素 或 指向容器中尾元素的下个位置</p>
<ul>
<li>使用迭代器<ul>
<li>有迭代器的类型也拥有 返回迭代器的成员</li>
<li>begin成员：返回 指向第一个元素的迭代器</li>
<li>end成员： 返回 指向容器（或string）“尾元素的下一个位置”的迭代器（尾后迭代器</li>
<li>容器为空，则begin和end指向同一个迭代器（尾后迭代器</li>
<li>不在意迭代器的准确类型，可用auto</li>
<li>迭代器相等：指向的元素相同，或指向同一个尾后迭代器</li>
<li>解引用（*）迭代器来获取所指元素，前提是迭代器合法且有所指。</li>
<li>end返回的迭代器不能递增或解引用</li>
<li><strong>泛型编程</strong>：c++ 比如在for循环中，尽可能使用迭代器和!= == ，所有标准库容器都定义了。但很多都没有定义&lt;和&gt;。</li>
<li>迭代器类型：标准库使用iterator、const_iterator表示。const_iterator和常量指针类似</li>
<li>迭代器：认定某个类型是迭代器–它支持一套操作，使我们能访问容器的元素 或 从某一个元素移动到另外一个元素</li>
<li>begin和end返回的类型由对象是否是常量决定 iterator 或const_iterator</li>
<li>cbegin，cend一定返回const_iterator</li>
<li>箭头运算符：解引用+成员访问</li>
<li>任何一种改变vector容量的操作，都会使它的迭代器失效。若循环体使用了迭代器，不要向对应容器添加元素。</li>
</ul>
</li>
<li>迭代器运算<ul>
<li>算术运算<ul>
<li>迭代器距离，类型为difference_type 带符号整型。</li>
</ul>
</li>
<li>使用迭代器运算<ul>
<li>二分搜索：有序序列中寻找给定值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><p>存放 类型相同的对象 的容器。数组大小确定不变，不能随意向数组中添加元素。</p>
</li>
<li><p>不清楚元素确切个数–用vector</p>
</li>
<li><p>定义和初始化内置数组</p>
<ul>
<li><p>维度：数组元素的个数，必须是常量表达式。</p>
</li>
<li><p>数组元素被默认初始化。若在函数体内，默认初始化后，数组就会含有未定义的值</p>
</li>
<li><p>定义数组不能用auto推断列表</p>
</li>
<li><p>显示初始化：剩余元素被初始化为默认值。</p>
</li>
<li><p>字符串初始化字符数组时，要注意：字符串结尾有一个空字符。注意数组维度</p>
</li>
<li><p>不允许数组拷贝和赋值。一些编译器扩展支持数组赋值，但最好避免使用非标准特性。</p>
</li>
<li><p><strong>复杂的数组声明</strong>：从内向外阅读，优先级最高的决定这是什么</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];					<span class="comment">//指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]=<span class="comment">/* ??? */</span>;		<span class="comment">//引用的数组 不存在这种，引用不是对象</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>]= &amp;arr;		<span class="comment">//数组的指针</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]= arr;			<span class="comment">//数组的引用</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>]= ptrs;			<span class="comment">//指针的数组的引用</span></span><br><span class="line"><span class="keyword">int</span> (*(&amp;x))[<span class="number">10</span>]=Parray;  		<span class="comment">//数组的指针的引用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问数组元素</p>
<ul>
<li>数组下标为size_t类型 无符号类型。在cstddef头文件中定义</li>
<li>下标运算符由c++语言直接定义</li>
<li>for语句遍历数组所有元素</li>
<li>注意检查下标的值是否合法</li>
</ul>
</li>
<li><p>指针和数组</p>
<ul>
<li>对数组元素取地址，可以得到指向该元素的指针</li>
<li>编译器会将数组转换为 指向首元素的指针</li>
<li>auto的初始值是数组时，会得到指针类型；但decltype返回的类型是数组</li>
<li>数组的指针也是迭代器，同样，不能对尾后指针进行解引用或递增等操作。</li>
<li>begin和end函数：将数组作为参数。分别返回首元素指针和尾后指针。 注意尾后指针不能解引用和递增</li>
<li>指针运算：相减的结果类型是ptrdiff_t类型，是带符号类型，也定义在cstddef头文件中<ul>
<li>运算同样适用于空指针 和 指向非数组的指针</li>
</ul>
</li>
<li>解引用和指针运算的交互</li>
<li>下标与指针：使用下标运算符时，编译器对指向数组的指针执行下标运算<ul>
<li>·和标准库的string  vector 不同（下标无符号） ，<strong>数组的下标运算符可以处理负值</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>C风格字符串</p>
<ul>
<li>c++程序中最好不要使用</li>
<li>C风格字符串是一种写法，字符串存在字符数组中，并以空字符结束。(‘\0’) 一般用指针操作</li>
<li>C标准库string函数：定义在cstring头文件中。<ul>
<li>传入此类函数的指针 <strong>必须指向空字符结尾的数组</strong></li>
</ul>
</li>
<li>比较字符串：与比较string不同。若直接使用运算符比较，实际比较的是 指向数组首元素的指针<ul>
<li>若两个指针未指向同一对象，将得到未定义的结果</li>
<li>需要调用strcmp函数，比较字符串</li>
</ul>
</li>
<li>使用strcpy和strcat函数拷贝和连接字符串数组，需要预先考虑数组大小。</li>
<li>因此尽可能使用标准库的string，更安全也更高效</li>
</ul>
</li>
<li><p>与旧代码的接口</p>
<ul>
<li>C++程序与旧代码的衔接</li>
<li>混用string和c风格字符串<ul>
<li>用空字符结尾的字符数组初始化string</li>
<li>相关运算中，允许使用空字符结尾的数组作为 <strong>其中一个运算对象</strong></li>
<li>string的成员函数c_str，返回一个c风格的字符串（返回指针指向空字符结尾的数组，指针类型为const char*。</li>
<li>使用c_str函数，最好拷贝一份返回的数组进行后续操作</li>
</ul>
</li>
<li>数组初始化vector对象<ul>
<li>指明拷贝区域的首元素地址和尾后地址（使用对应指针构造）</li>
</ul>
</li>
<li>C++程序尽量使用vector和迭代器，避免使用内置数组和指针；尽量使用string，避免使用c风格字符串</li>
</ul>
</li>
</ul>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>C++的多维数组，其实是数组的数组。</p>
<ul>
<li>二维数组 第一维称为行，第二维称为列</li>
<li>多维数组的初始化：花括号括起来的一组值初始化</li>
<li>多维数组的下标引用：每个维度对应一个下标运算符</li>
<li>范围for语句处理多维数组<ul>
<li>若要改变元素的值，需要把控制变量声明为引用类型</li>
<li><strong>除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。防止外层变量被自动转成指针，内层就开始在指针内遍历（不合法）。</strong></li>
</ul>
</li>
<li>指针和多维数组<ul>
<li>程序使用多维数组的名字时，也会自动将其转换为指向首元素的指针，实际上是指向第一个内层数组的指针。</li>
<li>可以使用auto或decltype，避免声明指针时，在数组前面加上指针类型。</li>
<li>类型别名 简化 多维数组的指针</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>string对象是一个可变长的字符序列</li>
<li>vector对象是一组同类型对象的容器</li>
<li>迭代器允许对容器中的对象进行间接访问，可以用于访问string和vector的元素或在元素间移动</li>
<li>数组和 指向数组的指针在一个较低的层次上实现了与标准库类型string和vector类似的功能。一般来说，应该优先选用标准库提供的类型，之后再考虑c++语言内置的底层替代品：数组和指针。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第六章</title>
    <url>/2020/07/21/c-primer-6/</url>
    <content><![CDATA[<h3 id="第6章-函数"><a href="#第6章-函数" class="headerlink" title="第6章 函数"></a>第6章 函数</h3><p>本章首先介绍函数的定义和声明，接下来介绍重载函数的方法，以及编译器如何从函数的若干重载形式中选取一个与调用匹配的版本。最后，介绍一些关于函数指针的知识。</p>
<a id="more"></a>

<p>函数是命名的代码块，调用函数执行相应的代码。</p>
<p>函数可以有0个或多个参数，通常会产生一个结果。</p>
<p>可以重载函数，同一个名字可以对应几个不同的函数</p>
<h4 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h4><ul>
<li>函数定义：返回类型+函数名字+形参列表+函数体</li>
<li>使用 <strong>调用运算符</strong> 执行函数：一对圆括号，其中是一个逗号隔开的 <strong>实参</strong>列表。使用实参初始化形参，调用表达式的类型就是函数的类型</li>
<li>函数调用<ul>
<li>用定义并用实参初始化 函数对应的形参</li>
<li>将控制权转移给被调用函数</li>
<li>主调函数执行中断，被调函数开始执行</li>
<li>return语句：返回return语句中的值；将控制权从被调函数移回主调函数</li>
<li>函数返回值 初始化 调用表达式的结果</li>
</ul>
</li>
<li>形参和实参<ul>
<li>实参是形参的初始值，存在数量对应、一一对应关系</li>
<li>未规定实参的求值顺序</li>
<li>实参类型与对应形参类型匹配，或能转换为形参类型</li>
<li>形参列表可以为空，但不能省略。可以用void表示函数没有形参。</li>
<li>形参列表中，每个形参的类型都要注明；形参不能同名</li>
<li>函数最外层作用域的局部变量不能与形参同名</li>
<li>形参可以不命名，表示函数体不使用，但也需要一个对应的实参</li>
</ul>
</li>
<li>函数返回类型<ul>
<li>void返回类型：函数不返回任何值</li>
<li>函数的返回类型不能是数组或函数，但可以是指向它们的指针</li>
</ul>
</li>
<li>局部对象<ul>
<li>名字的作用域：程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期：程序在执行过程中，该对象存在的一段时间</li>
<li>局部变量：形参和函数体内部定义的变量<ul>
<li>隐藏在外层作用域中同名的其他所有声明中</li>
</ul>
</li>
<li>函数体外对应的对象存在于程序的整个执行过程中，程序启动时创建，程序结束时销毁</li>
<li>局部变量的声明周期依赖于定义的方式</li>
<li>自动对象：只存在于块执行期间的对象，块执行结束后，其值变为未定义<ul>
<li>形参是自动对象，传递给函数的实参初始化该自动对象。</li>
<li>变量定义含有初始值—用这个初始值初始化</li>
<li>变量定义不含初始值—默认初始化</li>
<li>内置类型的未初始化局部变量–产生未定义的值（默认初始化</li>
</ul>
</li>
<li>局部静态对象：声明周期贯穿函数调用 以及 <strong>之后的时间</strong>，局部变量定义成static类型。<ul>
<li>程序第一次经过定义时初始化，直到程序终止才被销毁。及时函数结束执行也不影响</li>
<li>没有显式的初始值，执行 <strong>值初始化</strong>；内置类型的局部静态变量初始化为0</li>
</ul>
</li>
</ul>
</li>
<li>函数声明<ul>
<li>函数名字必须在使用前声明</li>
<li>函数声明无需函数体，用一个分号替代即可</li>
<li>声明时可以写上形参的名字</li>
<li><strong>也被称作函数原型</strong></li>
<li>三要素（返回类型 函数名 形参类型）描述了函数的接口，说明了调用该函数所需的全部信息</li>
<li>在头文件中函数声明，在源文件中定义，<strong>包含函数声明头文件</strong></li>
</ul>
</li>
<li>分离式编译：把程序分割到几个文件中去，每个文件独立编译<ul>
<li>分别编译代码文件</li>
<li>产生后缀名是.obj（win）或.o（UNIX）的文件，代表该文件包含对象代码</li>
<li>编译器把对象文件 <strong>链接</strong>在一起，形成可执行文件</li>
</ul>
</li>
</ul>
<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><ul>
<li><p>每次调用函数都会重新创建它的形参，并用传入的实参对形参进行初始化</p>
</li>
<li><p>形参是引用，会绑定到实参上；实参被 引用传递，函数被 传引用调用。引用形参是对应实参的别名</p>
</li>
<li><p>否则将实参的值拷贝后赋给形参，形参和实参是两个相互独立的对象。实参被值传递，函数被传值调用。</p>
</li>
<li><p>传值参数</p>
<ul>
<li>初始化 非引用类型的变量，初始值拷贝给变量。对变量的改动不影响初始值</li>
<li>传值参数同上，函数对形参做的所有操作都不会影响实参 </li>
<li>指针形参：指针形参和指针实参是两个不同的指针，但指向同一个值。可以通过指针形参改变实参所指对象的值，但实参本身没有改变。</li>
<li>建议使用引用类型的形参代替指针，访问函数外部对象</li>
</ul>
</li>
<li><p>传引用参数</p>
<ul>
<li><p>使用引用形参，允许函数改变一个或多个实参的值</p>
</li>
<li><p>某种类型不支持拷贝时，函数只能通过引用形参访问该类型的对象</p>
</li>
<li><p>使用引用来避免拷贝，但如果函数无须拷贝，形参最好使用常量引用</p>
</li>
<li><p>给函数传入额外的引用实参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Three</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//传入额外的引用实参b，是的函数被调用时，除了修改a的值外，返回额外的信息b</span></span><br><span class="line">	a=<span class="number">3</span>;</span><br><span class="line">	b++;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Three(j,k);<span class="comment">//输出3</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出k=1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>const形参和实参</p>
<ul>
<li><p>用实参初始化形参时，会忽略顶层const。形参有顶层const时，传给它常量或非常量都可以。但可出现如下情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误，重复定义f(int)。因为顶层const被忽略，传入这两个函数的参数可以完全一样，形参列表没有明显区别，因此算作重复定义。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针或引用实参 与 const</p>
<ul>
<li>参数传递的初始化规则与指针、引用的初始化一致</li>
</ul>
</li>
<li><p>尽量使用常量引用</p>
<ul>
<li>普通引用会限制函数接收的实参类型（const对象、字面值、类型转换对象…)</li>
</ul>
</li>
</ul>
</li>
<li><p>数组形参</p>
<ul>
<li><p>不允许拷贝数组–无法以值传递的方式使用数组参数</p>
</li>
<li><p>使用数组时通常转为指针–传数组给函数时，实际上传递的是指向数组首元素的指针</p>
</li>
<li><p>可以把形参写成类似数组的形式，实参会自动转换为指向数组首元素的指针，匹配形参类型</p>
<ul>
<li>以数组作为形参的函数也必须确保使用数组时不越界</li>
</ul>
</li>
<li><p>数组以指针的形式传给函数，但不知道数组的确切尺寸，因此需要提供额外的信息</p>
</li>
<li><p>管理指针形参的三种常用技术</p>
<ul>
<li>要求数组本身含有一个结束标记，防止越界</li>
<li>使用标准库规范：向函数传递指向数组首元素和尾后元素的指针，传入的指针正确就安全</li>
<li>显式传递一个表示数组大小的形参<ul>
<li>专门定义一个表示数组大小的形参，和一个表示数组大小的形参</li>
<li>传递的数组大小不超过实际大小，就是安全的</li>
</ul>
</li>
</ul>
</li>
<li><p>不需要对数组执行写操作时，<strong>数组形参是指向const的指针</strong>；要改变数组元素值时，才把形参定义成非向量的指针</p>
</li>
<li><p>形参也可以是数组的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span><span class="comment">//形参是数组的引用，维度是类型的一部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> elem:arr)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//限制了print的可用性，实参必须是大小为10的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传递多维数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>],<span class="keyword">int</span> rowSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//max指向数组的首元素，该数组的元素是 由10个整数构成的数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>],<span class="keyword">int</span> rowSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>main：处理命令行选项</p>
<ul>
<li><p>main函数的可选形参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>argv是一个数组，元素是C风格字符串的指针；argc表示argv数组中字符串的数量</p>
</li>
<li><p>实参传给main函数之后，argv的第一个元素指向程序的名字或空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素保证为0</p>
</li>
<li><p>使用argv的实参时，可选的实参从argv[1]开始；argv[0]保存程序的名字，<strong>而非用户输入</strong></p>
</li>
</ul>
</li>
<li><p>含有可变形参的函数</p>
<ul>
<li>有时无法提前预知要向函数传递几个实参</li>
<li>c++11提供两种主要方法<ul>
<li>若所有实参类型相同，可以传递一个名为initializer_list的标准库类型</li>
<li>若实参类型不同，可以编写一种特殊的函数，也就是可变参数模板</li>
</ul>
</li>
<li>initializer_list形参<ul>
<li>标准库类型，表示 某种特定类型的值 的数组</li>
<li>定义在同名头文件中</li>
<li>和vector一样是一种模板类型</li>
<li><strong>其中的元素永远是常量型，无法改变其中元素的值</strong></li>
<li>向initializer_list形参中传递一个值的序列，需要把序列放在花括号内</li>
<li>含有initializer_list形参的函数，也可以同时拥有其他形参</li>
</ul>
</li>
<li>省略符形参（…)<ul>
<li>使用了名为varargs的C标准库功能</li>
<li>仅用于C和C++通用的类型，大多数类对象传给省略符形参时都不能正确拷贝</li>
<li>只能出现在形参列表的最后一个位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h4><ul>
<li><p>return语句终止当前正在执行的函数，并将控制权返回到调用该函数的地方。</p>
</li>
<li><p>无返回值函数：</p>
<ul>
<li>返回类型是void的函数</li>
<li>函数的最后一句后会隐式执行return</li>
<li>想提前退出，用return</li>
<li>void函数也能返回表达式，但必须是另一个返回void的函数</li>
</ul>
</li>
<li><p>有返回值函数</p>
<ul>
<li><p>函数内的return必须返回一个值</p>
</li>
<li><p>返回值的类型必须与函数的返回类型相同，或能隐式转换为函数的返回类型</p>
</li>
<li><p>具有返回值的函数只能通过一条有效的return语句退出</p>
</li>
<li><p>含有return语句的循环后面应该也有一条return语句。</p>
</li>
<li><p>返回值的方式和初始化一个变量或形参是一样的：返回的值用于初始化调用点的一个临时量，即函数调用的结果</p>
</li>
<li><p>不要返回局部对象的引用或指针</p>
<ul>
<li><p>函数完成后，所占的存储空间也被释放，此时局部变量的引用将指向无效的内存区域</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> ret;</span><br><span class="line">	<span class="keyword">if</span>(!ret.empty())<span class="keyword">return</span> ret;<span class="comment">//错误，返回局部对象的引用</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"Empty"</span>;<span class="comment">//错误，字面值转换为局部临时的string对象，返回局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回局部对象的引用和指针都是错误的</p>
</li>
</ul>
</li>
<li><p>返回类 类型的函数和调用运算符</p>
<ul>
<li>若函数返回指针、引用或类的对象，就能使用调用结果访问结果对象的成员</li>
</ul>
</li>
<li><p>引用返回左值</p>
<ul>
<li>函数的返回类型决定函数调用是否是左值</li>
<li>调用一个 返回引用 的函数得到左值，可以放在赋值语句的左侧；调用其他函数得到右值。</li>
<li>若返回类型是常量引用，不能给调用的结果赋值。</li>
</ul>
</li>
<li><p>列表初始化返回值</p>
<ul>
<li>c++11规定，函数可以返回花括号包围的值的列表，列表也对函数返回的临时量进行初始化</li>
<li>若函数返回的是内置类型，花括号包围的列表最多包含一个值，且该值所占空间不能大于目标类型的空间</li>
</ul>
</li>
<li><p>主函数main的返回值</p>
<ul>
<li><p>允许main函数没有返回值直接结束，编译器会在最后隐式插入一条返回0的return语句</p>
</li>
<li><p>cstdlib头文件定义了两个预处理变量，可以使用这两个变量表示成功或失败</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(some_failure)</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;<span class="comment">//定义在cstdlib</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//定义在cstdlib</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>递归</p>
<ul>
<li>递归函数：调用自身</li>
<li>递归循环：函数不断调用自身，直到程序栈空间耗尽</li>
<li>main函数不能调用自身</li>
</ul>
</li>
</ul>
</li>
<li><p>返回数组指针</p>
<ul>
<li><p>函数不能返回数组，但可以返回数组的指针或引用</p>
</li>
<li><p>使用类型别名返回数组指针</p>
</li>
<li><p>声明一个返回数组指针的函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];<span class="comment">//函数声明</span></span><br></pre></td></tr></table></figure>

<ul>
<li>func(int i)表示调用func函数需要一个int实参</li>
<li>(*func(int i))表示可以对函数调用的结果执行解引用操作</li>
<li>int (*func(int i)) [10]表示，对func的调用结果解引用，可以得到一个大小为10的int型数组</li>
</ul>
</li>
<li><p>使用尾置返回类型</p>
<ul>
<li><p>c++11</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto func(int i) -&gt; int(*)[10]//func接收一个int型的实参，返回一个指针，指针指向大小为10的int型数组</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾置返回类型跟在形参列表后面，前面用auto代替原来的返回类型</p>
</li>
</ul>
</li>
<li><p>使用decltype</p>
<ul>
<li>如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型</li>
<li>注意decltype的结果是数组，因此声明的函数返回指针时，还要记得加*号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><ul>
<li><p>重载函数：同一作用域内的几个函数名字相同，但形参列表不同。</p>
</li>
<li><p>调用重载函数时，编译器根据传递的实参类型推断想要的是哪个函数</p>
</li>
<li><p>main函数不能重载</p>
</li>
<li><p>定义重载函数</p>
<ul>
<li>不允许两个函数除了返回类型外，其他所有的要素都相同</li>
<li>不允许形参列表一样，但返回类型不同（报错</li>
</ul>
</li>
<li><p>判断形参类型是否相异</p>
<ul>
<li>形参名字不影响形参列表的异同判断</li>
<li>类型别名与形参异同无关</li>
</ul>
</li>
<li><p>重载和const形参</p>
<ul>
<li>顶层const不影响传入函数的对象，因此顶层const无法区分形参异同</li>
<li>底层const可以区分形参异同（指向常量还是非常量对象）<ul>
<li>若传递非常量对象或指向非常量的指针，编译器优先选择非常量版本的函数</li>
</ul>
</li>
</ul>
</li>
<li><p>有时不需要重载函数，以保留函数名中本来拥有的信息</p>
</li>
<li><p>const_cast和重载</p>
<ul>
<li><p>一个函数的形参和返回类型都是const型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数和返回类型都是const string的引用，实参可以是非常量，但结果还是const string的引用。</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;=s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载函数，实参不是常量时，返回普通的引用</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">f</span><span class="params">(<span class="built_in">string</span> &amp;s1,<span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//实参强制转换为对const的引用，以调用上面的函数，函数返回对const的引用</span></span><br><span class="line">	<span class="keyword">auto</span> &amp;r=f(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">	<span class="comment">//返回值实际上绑定的是非const的值，因此强制转换为普通的引用，并返回。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个重载函数的意义：如果直接强制转换第一个函数的返回类型，有可能会把绑定const的const引用转换为非const引用，这是不安全的。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用重载的函数</p>
<ul>
<li>函数匹配/重载确定：把函数调用与一组重载函数中的某一个 关联起来</li>
<li>复杂的情况：重载函数的参数数量相同，且参数类型可以相互转换</li>
<li>三种可能结果<ul>
<li>编译器找到了与实参 最佳匹配 的函数，并调用该函数</li>
<li>找不到任何一个函数与调用的实参匹配，编译器报 无匹配 的错误</li>
<li>有多于一个函数可以匹配，但都不是最佳选择，报错。二义性调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>重载与作用域</p>
<ul>
<li>尽量不在局部作用域中声明函数</li>
<li>若在内层作用域中声明名字，<strong>它将隐藏外层作用域中声明的同名实体</strong></li>
<li>在不同的作用域中无法重载函数名</li>
<li>c++中，名字查找发生在类型检查之前</li>
</ul>
</li>
</ul>
<h4 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h4><ul>
<li><p>默认实参</p>
<ul>
<li><p>在函数的很多次调用中，总是被赋予一个相同的值的形参。反复出现的值就是默认实参</p>
</li>
<li><p>可以在函数声明时，为形参提供默认实参</p>
</li>
<li><p>一旦某个形参被赋予了默认值，<strong>后面的所有形参都必须有默认值</strong></p>
</li>
<li><p>使用默认实参调用函数</p>
<ul>
<li>在调用函数时省略该实参</li>
<li>调用时，实参按位置解析，默认实参填补缺少的尾部实参（靠右侧）</li>
<li>合理设置形参的顺序，不怎么使用默认值的形参出现在前面</li>
</ul>
</li>
<li><p>默认实参声明</p>
<ul>
<li>在给定的作用域中，一个形参只能被赋予一次默认实参</li>
<li>函数的后续声明只能为之前没有默认值的形参添加 默认实参</li>
</ul>
</li>
<li><p>默认实参初始值</p>
<ul>
<li><p>局部变量不能作为默认实参</p>
</li>
<li><p>表达式类型能转换成形参所需的类型，该表达式就能作为默认实参</p>
</li>
<li><p>用作默认实参的名字在函数声明所在的作用域内解析，这些名字的求值过程发生在函数调用时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size_type sz;<span class="comment">//类型别名</span></span><br><span class="line">sz wd=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def=<span class="string">' '</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz=ht(),sz=wd,<span class="keyword">char</span>=def)</span></span>;<span class="comment">//使用默认实参声明函数</span></span><br><span class="line"><span class="built_in">string</span> window =screen();<span class="comment">//调用screen(ht(),80,' ')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	def=<span class="string">'*'</span>;<span class="comment">//改变默认实参的值</span></span><br><span class="line">	sz wd=<span class="number">100</span>;<span class="comment">//声明局部变量wd，隐藏了外层定义wd，但没有改变screen的默认实参，与screen的默认实参无关</span></span><br><span class="line">	window=screen();<span class="comment">//调用screen(ht(),80,'*')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内联函数和constexpr函数</p>
<ul>
<li>小规模操作定义为函数的优缺点<ul>
<li>可读性更好</li>
<li>确保相关操作统一</li>
<li>更容易修改操作过程</li>
<li>可以被其他应用重复利用</li>
<li>调用函数会稍慢一点</li>
</ul>
</li>
<li>内联函数可避免函数调用的开销<ul>
<li>将函数在每个调用点上“内联地”展开，（直接在调用点展开</li>
<li>函数的返回类型前加关键字<strong>inline</strong>，即可声明为内联函数</li>
<li>内联说明 是向编译器发出的一个请求</li>
<li>内联机制用于优化规模较小、流程直接、频繁调用的函数</li>
<li>很多编译器不支持内联递归函数</li>
</ul>
</li>
<li>constexpr函数<ul>
<li>能作用于常量表达式的函数</li>
<li>函数的返回类型及所有形参的类型都得是字面值类型</li>
<li>函数体中有且只有一条return语句</li>
<li>函数体内除了return，可以包含其他语句，但这些语句在运行时不能执行任何操作</li>
<li>constexpr函数不一定返回常量表达式</li>
</ul>
</li>
<li>把内联函数和constexpr函数放在头文件内<ul>
<li>对于给定的内联函数或constexpr函数，它的多个定义必须完全一致</li>
<li>因此内联函数和constexpr函数，通常定义在头文件中</li>
</ul>
</li>
</ul>
</li>
<li><p>调试帮助</p>
<ul>
<li><p>程序可以包含调试代码，但只在开发程序时使用。程序编写完准备发布时，要先屏蔽掉调试代码</p>
</li>
<li><p>assert预处理宏</p>
<ul>
<li>预处理宏：预处理变量</li>
<li>assert宏定义在cassert头文件中</li>
<li>对assert的表达式求值，若表达式为假（0），assert输出信息并终止程序执行；若表达式为真（非0），assert什么也不做</li>
<li>宏名字在程序内必须唯一，最好不要为了其他目的使用assert</li>
<li>常用于检查“不能发生”的条件</li>
</ul>
</li>
<li><p>NDEBUG预处理变量</p>
<ul>
<li><p>assert的行为依赖于NDEBUG预处理变量的状态</p>
</li>
<li><p>若定义了NDEBUG，assert什么也不做；默认状态下没有定义NDEBUG，assert将执行运行时检查</p>
</li>
<li><p>可以使用#define语句定义NDEBUG，从而关闭调试状态</p>
</li>
<li><p>很多编译器提供了命令行选项使我们可以定义预处理变量</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ CC -D NDEBUG main.C # use /D with the Microsoft compiler</span><br></pre></td></tr></table></figure>
</li>
<li><p>这条命令在main.C文件的一开始写#define NDEBUG</p>
</li>
<li><p>定义NDEBUG能避免检查各种条件所需的运行时开销，此时不会执行运行时检查</p>
</li>
<li><p>assert仅用于验证 确实不可能发生的事情</p>
</li>
<li><p>也可以使用NDEBUG编写自己的条件调试代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若NDEBUG未定义，执行之间的代码；否则代码被忽略</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器定义的局部静态变量，便于调试</p>
<ul>
<li>__ func __ 当前调试的函数名</li>
<li>__ FILE __ 存放文件名的字符串字面值</li>
<li>__ LINE __ 存放当前行号的整型字面值</li>
<li>__ TIME __ 存放文件编译时间的字符串字面值</li>
<li>__ DATE __ 存放文件编译日期的字符串字面值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h4><ul>
<li><p>对于几个重载函数的形参数量相等，某些形参的类型可以由其他类型转换，该怎么选重载函数？</p>
</li>
<li><p>确定候选函数和可行函数</p>
<ul>
<li>选定候选函数：本次调用对应的重载函数集 中的函数<ul>
<li>与被调用的函数同名</li>
<li>声明在调用点可见</li>
</ul>
</li>
<li>考察本次调用提供的实参，从候选函数中选出能被这组实参调用的函数–<strong>可行函数</strong><ul>
<li>形参数量与调用提供的实参数量相等</li>
<li>每个实参的类型与对应的形参类型相同，或能转换成形参的类型</li>
</ul>
</li>
<li>若函数含有默认实参，调用时传入的实参数量可能少于实际使用的实参数量</li>
<li>若没找到可行函数，编译器报错：无匹配函数</li>
</ul>
</li>
<li><p>寻找最佳匹配</p>
<ul>
<li>从可行函数中选择与本次调用最匹配的函数（形参与实参 最匹配）<ul>
<li>形参与实参类型越接近，匹配得越好</li>
<li>精确匹配&gt;类型转换的匹配</li>
</ul>
</li>
</ul>
</li>
<li><p>含有多个形参的函数匹配</p>
<ul>
<li>匹配条件<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数的匹配</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
</ul>
</li>
<li>若检查所有实参后，没有一个函数脱颖而出，则报调用错误：二义性调用</li>
</ul>
</li>
<li><p>调用重载函数时，应尽量避免强制类型转换。</p>
</li>
<li><p>实参类型转换</p>
<ul>
<li><p>优先级</p>
<ul>
<li>精确匹配：实参=形参，数组或函数转指针，实参的顶层const</li>
<li>const转换实现的匹配</li>
<li>类型提升实现的匹配</li>
<li>算术类型转换或指针转换实现的匹配</li>
<li>类 类型转换实现的匹配</li>
</ul>
</li>
<li><p>小整型会直接提升到int或更大，若有int和short形参的重载，会直接提到int，匹配int版本</p>
</li>
<li><p>所有算术转换的优先级一样，double既能转换为long也能转换为float，因此double型调这两个版本的重载，会报二义性调用错误</p>
</li>
<li><p>函数匹配和const实参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;<span class="comment">//形参是普通引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;<span class="comment">//形参是常量引用</span></span><br><span class="line"><span class="keyword">const</span> Account a;<span class="comment">//常量对象a</span></span><br><span class="line">Account b;<span class="comment">//非常量对象b</span></span><br><span class="line"></span><br><span class="line">lookup(a);<span class="comment">//调用lookup(const Account&amp;)，a是常量对象，只有常量引用能绑定常量对象</span></span><br><span class="line">lookup(b);<span class="comment">//调用lookup(Account&amp;)，b是非常量对象，若形参是常量引用，会发生类型转换；因此选择精确匹配的非常量引用版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>引用：如果两个函数的唯一区别是形参是常量引用或非常量引用，编译器通过实参来确定选择哪个函数，具体如上</li>
<li>指针：若两个函数的唯一区别是指针形参指向常量或非常量，则编译器能通过实参决定选择哪个函数，实参指向常量，调const*的函数；实参指向非常量，调普通指针的函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><ul>
<li><p>指向函数而非对象</p>
</li>
<li><p>函数的类型由返回类型和形参类型共同决定，与函数名无关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;<span class="comment">//声明一个int函数f</span></span><br><span class="line"><span class="keyword">int</span> （*pf）（<span class="keyword">int</span> a,<span class="keyword">int</span> b);<span class="comment">//pf指向一个函数，该函数的形参是两个int，返回int</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">pf</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;<span class="comment">//pf是一个函数，该函数形参是两个int，返回指向int的指针</span></span><br><span class="line"><span class="comment">//指针两端的括号不能少，不然意思就一样</span></span><br><span class="line"></span><br><span class="line">pf=f;<span class="comment">//pf指向函数f</span></span><br><span class="line">pf=&amp;f;<span class="comment">//与上一条等价，取地址符可选</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数指针,以下三种调用等价</span></span><br><span class="line"><span class="keyword">int</span> k1=pf(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> k2=(*pf)(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> k3=f(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用函数指针</p>
<ul>
<li>把函数名作为一个值使用时，该函数自动转换为指针</li>
<li>指向不同函数类型的指针之间没有转换规则</li>
<li>可以给函数指针赋一个nullptr或值为0的整型常量表达式，表示该指针没有指向任何一个函数</li>
<li>给函数指针赋值，注意类型要精确匹配</li>
</ul>
</li>
<li><p>重载函数的指针</p>
<ul>
<li>若定义了重载函数的指针，编译器通过指针类型决定选哪个函数，指针类型必须与重载函数中的某一个精确匹配</li>
</ul>
</li>
<li><p>函数指针形参</p>
<ul>
<li>不能定义函数 类型的形参，但形参可以是指向函数的指针</li>
<li>可以直接把函数作为实参使用，此时它会自动转换成指针</li>
<li>可以用typedef和decltype简化函数指针的形参声明</li>
</ul>
</li>
<li><p>返回指向函数的指针</p>
<ul>
<li><p>不能返回一个函数，但可以返回指向函数类型的指针</p>
</li>
<li><p>返回类型必须写成指针形式</p>
</li>
<li><p>使用类型别名，声明 返回函数指针 的函数；必须显式地将返回类型指定为指针</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F=<span class="keyword">int</span>(<span class="keyword">int</span>*,<span class="keyword">int</span>);<span class="comment">//F是函数类型的别名</span></span><br><span class="line"><span class="keyword">using</span> PF=<span class="keyword">int</span> (*)(<span class="keyword">int</span>*,<span class="keyword">int</span>);<span class="comment">//PF是指向函数的指针的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//正确：f1返回指向函数的指针PF</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//错误：f1不能返回函数类型</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//正确：f1返回指向函数F的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接声明f1，f1有形参列表，f1是函数，返回一个指针，指针指向一个返回int型的，形参是一个int的函数</span></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*,<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//使用尾置返回类型的方式声明：返回函数指针的函数</span></span><br><span class="line">auto f1(int) -&gt; int (*)(int*,int);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>将auto和decltype用于函数指针类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(f1) *f3(<span class="keyword">int</span> a);<span class="comment">//声明函数f3，返回一个指向f1或f2的指针</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>二义性调用</li>
<li>自动对象</li>
<li>最佳匹配</li>
<li>候选函数</li>
<li>内联函数</li>
<li>对象生命周期</li>
<li>重载函数</li>
<li>值传递/引用传递</li>
<li>递归循环</li>
<li>分离式编译</li>
<li>尾置返回类型</li>
<li>可行函数</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第七章</title>
    <url>/2020/07/23/c-primer-7/</url>
    <content><![CDATA[<h3 id="第7章-类"><a href="#第7章-类" class="headerlink" title="第7章 类"></a>第7章 类</h3><p>在C++语言中，我们使用类定义自己的数据类型。通过定义新的类型来反映待解决问题中的各种概念，可以使我们更容易编写、调试和修改程序。</p>
<p>本章是第2章关于类的话题的延续，主要关注数据抽象的重要性。数据抽象能帮助我们将对象的具体实现与对象所能执行的操作分离开来。</p>
<a id="more"></a>

<ul>
<li>类的基本思想是数据抽象和封装</li>
<li>数据抽象：依赖于 接口 和 实现 分离的编程技术</li>
<li>类的接口：包括用户所能执行的操作；</li>
<li>类的实现：包括类的数据成员、负责接口实现的函数体、定义类所需的各种私有函数</li>
<li>封装实现了类的接口和实现的分离。封装后的类隐藏了实现细节，用户只能使用接口，无法访问实现部分</li>
<li>类要首先定义一个抽象数据类型，由类的设计者考虑类的实现过程，使用该类的程序员只需要抽象思考类型做了什么，无须了解类型的工作细节</li>
</ul>
<h4 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h4><ul>
<li><p>要把类定义成抽象数据类型，需要定义一些操作以供类的用户使用，之后可以封装（隐藏）它的数据成员</p>
</li>
<li><p>设计类</p>
<ul>
<li>执行加法和IO的函数不作为类的成员，将其定义为普通函数；执行复合赋值运算的函数是成员函数</li>
<li>类的用户是程序员，应用程序的用户是实际的程序使用者。</li>
<li>良好设计的类，既要有直观且易于使用的接口，也必须具备高效的实现过程</li>
</ul>
</li>
<li><p>添加类的函数</p>
<ul>
<li>成员函数的声明必须在类的内部，定义可以在内部也可以在外部</li>
<li>作为接口组成部分的非成员函数，定义和声明都在类的外部</li>
<li>定义在类内部的函数是隐式的inline函数</li>
<li>引入this<ul>
<li>成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象</li>
<li>调用一个成员函数是，用请求该函数的对象地址初始化this</li>
<li>任何对类成员的直接访问都被看做this的隐式引用</li>
<li>自定义名为this的参数或变量 是非法的</li>
<li>this是一个常量指针，总是指向当前对象，不能改变this保存的地址</li>
</ul>
</li>
<li>引入const成员函数<ul>
<li>默认情况下，this的类型是指向类类型非常量版本的常量指针</li>
<li>因为this是常量指针，因此不能改绑定对象，从绑非常量改成绑常量；这样一来，就不能在常量对象上调用普通的成员函数‘</li>
<li>因此，把this设置为指向常量的指针有助于提高函数的灵活性</li>
<li>C++允许把const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针</li>
<li>这样使用const的成员函数被称作常量成员函数</li>
<li>常量成员函数不能改变调用它的对象的内容</li>
<li>常量对象，以及常量对象的引用或指针都只能调用常量成员函数</li>
</ul>
</li>
<li>类作用域和成员函数<ul>
<li>类本身就是一个作用域</li>
<li>编译器分两步处理类：首先编译成员声明，然后才编译成员函数体。成员函数可以随意使用类中的成员，不用在意顺序</li>
</ul>
</li>
<li>在类的外部定义成员函数<ul>
<li>成员函数的定义必须与类内部的对应声明匹配</li>
<li>使用作用域运算符：类外部的函数被声明在类的作用域内，也就可以在函数内部直接使用类的成员</li>
</ul>
</li>
<li>定义一个返回this对象的函数<ul>
<li>若定义的函数类似于某个内置运算符时，尽量模仿内置运算符，把左侧运算对象当成左值返回，因此这样的函数必须返回一个引用类型</li>
<li>可以使用解引用this指针来获得执行该函数的对象，最后函数返回该对象的引用</li>
</ul>
</li>
</ul>
</li>
<li><p>定义类相关的非成员函数</p>
<ul>
<li>一般来说，若非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内</li>
<li>定义read和print函数<ul>
<li>read和print函数分别接受一个各自IO类型的引用作为其参数；因为IO类属于不能诶拷贝的类型，因此我们只能通过引用来传递他们；而且，读取和写入都会改变流的内容，因此函数只能接受普通引用，不能接受常量引用</li>
<li>print函数不负责换行，一般来说，<strong>执行输出任务的函数应该尽量减少对格式的控制</strong>。确保由用户代码决定相关格式</li>
</ul>
</li>
<li>定义add函数<ul>
<li>默认情况下，拷贝类的对象其实是拷贝对象的数据成员</li>
</ul>
</li>
</ul>
</li>
<li><p>构造函数</p>
<ul>
<li><p>构造函数：类通过一个或几个特殊的成员函数来控制其对象的初始化过程</p>
</li>
<li><p>初始化类对象的数据成员</p>
</li>
<li><p>名字和类名相同，没有返回类型 </p>
</li>
<li><p>类可以包含多个构造函数，和重载函数类似，参数数量和类型有所区别</p>
</li>
<li><p>构造函数不能被声明为const</p>
</li>
<li><p>创建类的const对象时，构造函数先初始化，对象再获得常量属性，因此构造函数可以向const对象写值</p>
</li>
<li><p>合成的默认构造函数</p>
<ul>
<li>默认构造函数：无须实参，控制类的默认初始化；没有显式定义构造函数，编译器就会隐式定义默认构造函数</li>
<li>初始化类的成员：若存在类内初始值，用它来初始化成员；否则默认初始化该成员</li>
</ul>
</li>
<li><p>某些类不能依赖于合成的默认构造函数</p>
<ul>
<li>对普通的类来说，必须定义自己的默认构造函数<ul>
<li>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数</li>
<li>编译器合成的默认构造函数可能执行错误的操作，对内置和符合类型可能得到未定义的值</li>
<li>有时编译器不能为某些类合成默认的构造函数（类中有其他类的成员，且这个成员没有默认构造函数）</li>
</ul>
</li>
</ul>
</li>
<li><p>定义构造函数+构造函数初始值列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	A()=<span class="keyword">default</span>;<span class="comment">//默认构造函数</span></span><br><span class="line">    </span><br><span class="line">    A(<span class="keyword">const</span> <span class="keyword">int</span> b):c1(a) &#123; &#125;<span class="comment">//": c1(a)"为构造函数初始值列表</span></span><br><span class="line">	<span class="comment">//使用int对象初始化c1，成员c2，c3被隐式初始化    </span></span><br><span class="line">    </span><br><span class="line">    A(<span class="keyword">const</span> <span class="keyword">int</span> b,<span class="keyword">unsigned</span> d,<span class="keyword">double</span> e):c1(a),c2(d),c3(e*d) &#123; &#125;</span><br><span class="line">    <span class="comment">//":c1(a),c2(d),c3(e*d)"为构造函数初始值列表</span></span><br><span class="line">    <span class="comment">//使用前两个int和unsigned型参数初始化对象c1和c2，c3的初始值由后两个参数相乘得到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在参数列表后写上=default，要求编译器生成构造函数</li>
<li>如果编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员</li>
<li>构造函数的唯一目的是为数据成员赋初值，因此函数体是空的</li>
</ul>
</li>
<li><p>在类的外部定义构造函数</p>
<ul>
<li><p>特殊情况：以istream为参数的构造函数需要执行实际的操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data::Sales_data(<span class="built_in">std</span>::istream &amp;is)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">read</span>(is,*<span class="keyword">this</span>);<span class="comment">//read函数的作用是从is中读取一条图书交易信息，然后存入this对象中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在类的外部定义构造函数时，必须指明该构造函数是哪个类的成员，若名字和类型相同，则为构造函数</p>
</li>
<li><p>未出现在构造函数初始值列表中的成员，将通过相应的类内初始值（如果存在的话）初始化，或执行默认初始化</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>拷贝、赋值和析构</p>
<ul>
<li>若不主动定义这些操作，编译器将代替生成</li>
<li>编译器的生成版本将对对象的每个成员执行拷贝、赋值和销毁操作</li>
<li>某些类不能依赖于合成的版本<ul>
<li>当类需要分配类对象之外的资源时，编译器的合成版本常常会失效</li>
<li>很多需要动态内存的类 能且应该 使用vector对象或string对象管理必要的存储空间，避免分配/释放内存带来的复杂性</li>
<li>若类包含vector或者string成员，则其拷贝、赋值和销毁的合成版本能够正常工作</li>
<li>类中所有分配的资源都应该直接以类的数据成员的形式存储</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h4><ul>
<li>使用 访问说明符 加强类的封装性<ul>
<li>在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口</li>
<li>在private说明符之后的成员可以被类的成员函数访问，但不能被使用该类的代码访问；private部分封装了类的实现细节</li>
<li>构造函数和部分成员函数跟在public之后；数据恒源和实现部分的函数跟在private之后</li>
</ul>
</li>
<li>使用class或struct关键字<ul>
<li>struct和class的<strong>默认访问权限</strong>不一样，struct在第一个访问说明符之前的成员是public；class在第一个访问说明符之前的成员是private</li>
</ul>
</li>
<li>友元<ul>
<li>类可以允许其他类或函数访问它的非公有成员，方法是让其他类和函数称为它的友元</li>
<li>以friend关键字开始声明——友元声明</li>
<li>友元不是类的成员，也不受所在区域访问控制级别的约束</li>
<li>封装的益处<ul>
<li>确保用户代码不会无意间破坏封装对象的状态</li>
<li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码</li>
<li>改变类的定义无需更改用户代码，但使用了该类的源文件必须重新编译</li>
</ul>
</li>
<li>友元的声明<ul>
<li>友元的声明仅指定了访问的权限</li>
<li>若类需要调用一个友元函数，必须在友元声明之外再声明一次函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h4><ul>
<li><p>类成员再探</p>
<ul>
<li>类可以自定义某种类型在类中的别名（使用typedef或using）</li>
<li>用来定义类型的成员必须先定义后使用，因此类型成员通常出现在类开始的地方</li>
<li>定义在类内部的成员函数自动内联</li>
<li>inline成员函数与相应的类定义在同一个头文件中</li>
<li>重载成员函数</li>
<li>可变数据成员（mutable）：包括const成员函数的任何成员函数，都可以改变一个可变成员的值</li>
<li>类数据成员的初始值：类内初始值必须用=或花括号表示</li>
</ul>
</li>
<li><p>返回*this的成员函数</p>
<ul>
<li>返回 调用该函数的对象 的引用，返回的是对象本身而非副本</li>
<li>对于const成员来说，返回一个const引用，无法直接和非const引用混用<ul>
<li>对此，使用const重载解决</li>
</ul>
</li>
<li>对于公共代码使用私有功能函数</li>
</ul>
</li>
<li><p>类类型</p>
<ul>
<li>每个类定义了唯一的类型，即使两个类的成员列表完全一致，它们也是不同的类型</li>
<li>类的声明：可以仅声明而暂时不定义–前向声明，此时这个类的类型是 不完全类型<ul>
<li>对于不完全类型，可以定义它的指针或引用，也可以把它作为参数或返回类型 声明函数</li>
<li>但不能创建它的对象，直到类被定义后，数据成员才能被声明成这种类类型</li>
</ul>
</li>
</ul>
</li>
<li><p>友元再探</p>
<ul>
<li><p>类可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元</p>
</li>
<li><p>友元函数能定义在类的内部，这样的函数是隐式内联的。 </p>
</li>
<li><p>友元关系不存在传递性</p>
</li>
<li><p>每个类控制自己的友元类或友元函数</p>
</li>
<li><p>也可以令成员函数作为友元，注意顺序，以类B的友元函数a（属于类A）为例：</p>
<ul>
<li>先定义函数a所属的类A，声明函数但不定义</li>
<li>定义类B，包括对a的友元声明</li>
<li>定义a，使用B的成员</li>
</ul>
</li>
<li><p>若要把一组重载函数声明成它的友元，需要对这组函数中的每一个分别声明</p>
</li>
<li><p>友元声明的作用只是影响访问权限，并非声明了函数；可以先友元声明权限，但依旧需要声明函数。</p>
</li>
</ul>
</li>
</ul>
<h4 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h4><ul>
<li>每个类定义自己的作用域</li>
<li>在类的作用域外，使用作用域运算符访问类类型的成员</li>
<li>成员函数定义在类外部时，其返回类型在作用域外，因此也要指明是哪个类的成员</li>
<li>名字查找：寻找与所用名字最匹配的声明<ul>
<li>在名字所在的块中寻找声明语句，只考虑名字使用之前的声明</li>
<li>继续查找外层作用域</li>
<li>最终没找到，程序报错</li>
</ul>
</li>
<li>编译器处理完类中的全部声明后，才会处理成员函数的定义</li>
<li>若某个成员声明的名字类中没有，编译器会在定义该类的作用域中查找</li>
<li>在类中，若成员使用了外层作用域中的名字代表类型，则类不能再之后重新定义该名字</li>
<li>类型名的定义通常出现在类的开始处，确保所有使用该类型的成员都出现在类名的定义之后</li>
<li>成员函数中的名字查找：<ul>
<li>在成员函数内找（函数使用前的声明中找</li>
<li>类内继续找，所有成员都可以考虑</li>
<li>在成员函数定义前的作用域找</li>
</ul>
</li>
<li>加上类名或使用this指针，可以强制访问类的成员（可能被隐藏）</li>
<li>可以用作用域运算符，访问外层的对象（可能被隐藏</li>
</ul>
<h4 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h4><ul>
<li>构造函数初始值列表<ul>
<li>如果类的成员是const或引用的话，必须将其初始化。唯一的机会就是通过构造函数初始值</li>
<li>若成员是const、引用，或属于 未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值</li>
<li>养成使用构造函数初始值的习惯</li>
<li>构造函数初始值列表只说明用于初始化成员的值，不限定初始化的具体执行顺序；成员的初始化顺序与类定义一致<ul>
<li>最好令构造函数初始值的顺序与成员声明的顺序保持一致，且尽量避免使用某些成员初始化其他成员</li>
</ul>
</li>
<li>若一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数</li>
</ul>
</li>
<li>委托构造函数<ul>
<li>使用所属类的其他构造函数执行它自己的初始化过程，把自己的职责委托给了其他构造函数</li>
<li>非委托构造函数A使用对应的实参初始化成员；委托构造函数B C D等全都委托给构造函数A</li>
<li>受委托的构造函数A 的初始值列表和函数体被依次执行，若A的函数体包含代码，则先执行代码，再把控制权交还给委托者的函数体</li>
</ul>
</li>
<li>默认构造函数的作用<ul>
<li>默认初始化在以下情况发生<ul>
<li>在块作用域不使用任何初始值定义一个非静态变量或数组</li>
<li>类本身含有类类型的成员，且使用合成的默认构造函数</li>
<li>类类型的成员没有在构造函数初始值列表中显式初始化</li>
</ul>
</li>
<li>值初始化在以下情况发生<ul>
<li>数组初始化时，提供的初始值数量小于数组大小</li>
<li>不使用初始值定义局部静态变量</li>
<li>使用形如T()的表达式显式请求初始化时，T是类型名</li>
</ul>
</li>
<li>类必须包含一个默认构造函数以在上述情况下使用</li>
<li>若定义了其他构造函数，最好也提供一个默认构造函数</li>
<li>若想定义一个使用默认构造函数初始化的对象，要去掉对象名之后的空括号对</li>
</ul>
</li>
<li>隐式的类类型转换<ul>
<li>转换构造函数：只接受一个实参，实际定义了转换为此类类型的隐式转换机制（构造函数的参数类型转换为类类型）</li>
<li>编译器只会自动执行一步类型转换，转换超过一步就会报错</li>
<li>转换的类类型对象是一个临时量，处理完命令后就丢弃</li>
<li>抑制构造函数定义的隐式转换<ul>
<li>将构造函数声明为explicit，阻止隐式转换</li>
<li>explicit只对一个实参的构造函数有效，有多个实参的构造函数本来就不能隐式转换</li>
<li>只能在类内声明时使用explicit</li>
<li>explicit构造函数只能用于直接初始化</li>
<li>explicit构造函数不能隐式转换，但可以显式转换（使用构造函数或static_cast）</li>
</ul>
</li>
<li>标准库中含有显式构造函数（单参数）的类<ul>
<li>string构造函数，单参数-const char*</li>
<li>vector构造函数，单参数-容量</li>
</ul>
</li>
</ul>
</li>
<li>聚合类<ul>
<li>用户可以直接访问其成员，且具有特殊的初始化语法形式</li>
<li>满足如下条件的类是聚合类<ul>
<li>所有成员都是public</li>
<li>没有定义构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，没有virtual函数</li>
</ul>
</li>
<li>使用花括号括起来的成员值列表，初始化聚合类的数据成员，初始值顺序与声明顺序一致</li>
<li>若初始值列表中元素个数少于类的成员数量，靠后的成员被值初始化</li>
<li>显式初始化类成员的缺点<ul>
<li>类的所有成员都必须是public</li>
<li>初始化对象的任务交给了类的用户</li>
<li>添加或删除成员后，所有初始化语句都要更新</li>
</ul>
</li>
</ul>
</li>
<li>字面值常量类<ul>
<li>字面值类型的类可能含有constexpr成员，这些成员是隐式const的</li>
<li>数据成员都是字面值类型的聚合类 是 字面值常量类</li>
<li>符合下面要求的也是字面值常量类<ul>
<li>数据成员都是字面值类型</li>
<li>类至少含有一个constexpr构造函数</li>
<li>内置类型成员若有初始值，必须是一条常量表达式；若成员是类类型，初始值必须使用成员自己的constexpr函数</li>
<li>类必须使用析构函数的默认定义，负责销毁类的对象</li>
</ul>
</li>
<li>constexpr构造函数<ul>
<li>一个字面值常量类至少有一个constexpr函数</li>
<li>可以声明成=default或删除函数的形式，否则是空函数（同时满足构造函数和constexpr函数的要求）</li>
<li>必须初始化所有数据成员，初始值使用constexpr构造函数 或 常量表达式</li>
<li>用于生成constexpr对象以及constexpr函数的参数或返回类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h4><ul>
<li>与类本身直接相关，而不与类的各个对象保持关联</li>
<li>声明静态成员<ul>
<li>使用关键字static使成员与类关联在一起（静态成员</li>
<li>静态成员可以是public或private</li>
<li>静态成员存在于任何对象之外，对象中不包含与静态数据成员有关的数据</li>
<li>静态成员函数也不予任何对象绑定在一起，不包含this指针；不能声明为const，不能再static函数体内使用this指针</li>
</ul>
</li>
<li>使用类的静态成员<ul>
<li>使用作用域运算符直接访问静态成员</li>
<li>使用类的对象、引用、指针访问静态成员</li>
<li>成员函数可以直接使用静态成员</li>
</ul>
</li>
<li>定义静态成员<ul>
<li>在类的外部定义静态成员时，不能重复static，该关键字只出现在类内部的声明语句</li>
<li>必须在类的外部定义和初始化每个静态成员，定义在任何函数之外</li>
<li>将静态数据成员的定义和其他非内联函数的定义放在同一个文件中，确保对象只定义一次</li>
</ul>
</li>
<li>静态成员的类内初始化<ul>
<li>可以为静态成员提供const整型的类内初始值，但静态成员必须是字面值常量类型的constexpr，初始值必须是常量表达式</li>
<li>对于某个静态成员，若只用于可以替换值的情况，不需要在类外专门定义；若用于值不能替换的情况，该成员必须有一条定义语句</li>
<li>即使一个常量静态数据成员在类内部被初始化了，也应该在类的外部定义一下该成员</li>
</ul>
</li>
<li>静态成员的特殊场景<ul>
<li>静态数据成员可以是不完全类型，可以就是它所属的类类型；但非静态成员只能声明为所属类的指针或引用</li>
<li>可以使用静态成员作为默认实参；非静态成员不行</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>类有两项基本能力<ul>
<li>数据抽象：定义数据成员和函数成员</li>
<li>封装：保护类的成员不被随意访问</li>
</ul>
</li>
<li>类的特殊成员函数：构造函数<ul>
<li>控制初始化对象的方式</li>
<li>可以重载</li>
<li>使用构造函数初始值列表初始化所有数据成员</li>
</ul>
</li>
<li>可变或静态成员<ul>
<li>可变成员永远都不是const，在const成员函数内也能修改它的值</li>
<li>静态成员可以是函数或数据，存在于所有对象之外</li>
</ul>
</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>聚合类：只含有公有成员</li>
<li>常量成员函数</li>
<li>构造函数初始值列表</li>
<li>转换构造函数</li>
<li>数据抽象</li>
<li>委托构造函数</li>
<li>显式构造函数</li>
<li>前向声明</li>
<li>友元</li>
<li>不完全类型</li>
<li>合成默认构造函数</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第五章</title>
    <url>/2020/07/21/c-primer-5/</url>
    <content><![CDATA[<h3 id="第5章-语句"><a href="#第5章-语句" class="headerlink" title="第5章 语句"></a>第5章 语句</h3><p>本章将详细介绍c++语言支持的条件执行语句、重复执行相同代码的循环语句和用于中断当前控制流的跳转语句。</p>
<a id="more"></a>



<p>c++语句提供了一组控制流语句以支持更复杂的执行路径</p>
<h4 id="简单语句"><a href="#简单语句" class="headerlink" title="简单语句"></a>简单语句</h4><ul>
<li>表达式语句：执行表达式并丢弃求值结果</li>
<li>空语句：只含有单独的分号，常用于循环条件。使用空语句时加上注释</li>
<li>复合语句（块）：用花括号括起来的 语句和声明的序列<ul>
<li>一个块就是一个作用域，其中引入的名字只能在块内部以及子块里访问</li>
<li>块不以分号结束</li>
<li>空块：内部没有任何语句，等价于空语句</li>
</ul>
</li>
</ul>
<h4 id="语句作用域"><a href="#语句作用域" class="headerlink" title="语句作用域"></a>语句作用域</h4><ul>
<li>可在控制结构内自定义变量，语句结束后，变量超出其作用范围。</li>
<li>控制结构内的变量必须初始化</li>
</ul>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ul>
<li><p>if语句：根据条件决定控制流</p>
<ul>
<li>条件的类型必须能转换为布尔类型</li>
<li>嵌套if语句：使用花括号组合成块</li>
<li>悬垂else：c++规定，else与 离他最近的 且 尚未匹配的 if匹配</li>
<li>使用花括号控制执行路径</li>
</ul>
</li>
<li><p>switch语句：计算表达式的值，根据值从几条执行路径中选择一条</p>
<ul>
<li><p>break语句：中断当前的控制流</p>
</li>
<li><p>case标签：case和对应的值组成，case标签必须是 整型常量表达式</p>
</li>
<li><p>若某个case标签匹配成功，将从该标签向后顺序执行所有case分支，除非程序显式中断这一过程（如break语句）</p>
</li>
<li><p>case标签后不一定要换行，以强调它们代表的是某一范围的值</p>
</li>
<li><p>最好在标签后加上break</p>
</li>
<li><p>default标签：若所有case标签都不能匹配上switch表达式的值，执行default标签之后的语句</p>
</li>
<li><p>最好定义一个空的default标签，代表考虑了默认情况</p>
</li>
<li><p>不允许跨过变量的初始化语句，直接跳转到该变量作用域内的另一个位置</p>
<ul>
<li><p>应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之外</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> name=get_name();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">	<span class="keyword">if</span>(name.empty())<span class="comment">//直接报错，name变量在作用域之外</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h4><ul>
<li>通常称为循环。while和for语句在循环前检查条件；do while先循环，再检查条件。</li>
<li>while语句：只要条件为真，就重复执行循环体。条件不能为空<ul>
<li>定义在条件部分或循环体内的变量，每次迭代都经历创建到销毁的过程</li>
<li>不确定循环次数；循环结束后要访问循环控制变量：可以用while</li>
</ul>
</li>
<li>for语句<ul>
<li>for语句头：for+初始化值+循环控制条件+初始化变量修改</li>
<li>执行流程：初始化 判断条件 若为真-执行循环 修改初始化的控制变量值</li>
<li>for语句头中定义的变量只在循环体内可见</li>
<li>for语句头的多重定义：初始化部分只能有一条声明语句，<strong>因此声明变量的基础类型必须相同</strong></li>
<li>省略语句头的任意部分：分号必须保留。</li>
<li>范围for语句（c++11）：表达式必须是一个序列（列表、数组、拥有begin/end成员的类型）<ul>
<li>可以使用auto定义变量</li>
<li>对序列元素执行写操作，<strong>循环变量要声明成引用类型</strong></li>
<li>范围for语句预存了end()的值</li>
</ul>
</li>
</ul>
</li>
<li>do while语句<ul>
<li>先执行循环体，后检查条件，至少执行一次循环</li>
<li>条件后面要用 <strong>分号</strong>表示语句结束</li>
<li>条件不能为空，循环的条件变量必须定义在循环体之外。<strong>条件部分不能定义变量</strong></li>
</ul>
</li>
</ul>
<h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><ul>
<li><p>break语句：终止最近的while dowhile for switch语句，从这些语句之后的第一条语句开始继续执行。</p>
<ul>
<li>只能出现在迭代语句或switch语句内部</li>
</ul>
</li>
<li><p>continue语句：终止最近循环中的当前迭代，立即开始下一次迭代</p>
<ul>
<li>只能出现在for while dowhile内部或嵌套。</li>
<li>只有当switch嵌套时，才能用在switch内部。</li>
</ul>
</li>
<li><p>goto语句：无条件跳转到同一函数内的另一条语句</p>
<ul>
<li><p>不要在程序中使用goto语句，难理解、难修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line"><span class="built_in">end</span>: <span class="keyword">return</span>;<span class="comment">//带标签语句，可以作为goto的目标</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转向的带标签语句必须在<strong>同一函数内</strong></p>
</li>
<li><p><strong>不能将程序的控制权从变量的作用域之外转移到作用域之内？</strong></p>
<ul>
<li>不允许跨过变量声明跳转到该变量位置</li>
</ul>
</li>
<li><p>可以跳过已经执行的定义；跳回到变量定义前，会销毁并重新创建该变量</p>
</li>
</ul>
</li>
</ul>
<h4 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h4><ul>
<li><p>异常：运行反常行为，超出函数正常功能的范围。例如失去数据库连接、遇到意外输入等</p>
</li>
<li><p>异常处理：程序检测到无法处理的问题，发出某种信号表明遇到故障，<strong>无须知道故障将在何处解决</strong></p>
</li>
<li><p>异常处理机制</p>
<ul>
<li>throw表达式：异常检测。引发（raise）异常</li>
<li>try语句块：异常处理。以try开始，若干catch子句结束。catch子句处理异常，也被称为异常处理代码。</li>
<li>异常类：在throw表达式和catch子句之间传递异常的具体信息。</li>
</ul>
</li>
<li><p>throw表达式</p>
<ul>
<li><p>关键字throw+表达式（类型为抛出的异常类型）+分号，构成表达式语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a!=b)</span><br><span class="line">	<span class="keyword">throw</span> runtime_error(<span class="string">"ERROR!"</span>);<span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。</p>
</li>
</ul>
</li>
<li><p>try语句块</p>
<ul>
<li><p>try块+若干catch子句</p>
</li>
<li><p>catch子句包括：关键字catch+括号内的异常声明+一个块。选中catch子句处理异常之后，执行与之对应的块。</p>
</li>
<li><p>catch完成后，跳转到最后一个catch子句后的语句继续执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//执行正常情况的代码</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(runtime_error err)<span class="comment">//处理runtime_error的异常</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//异常处理</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;err.what()</span><br><span class="line">            &lt;&lt;<span class="string">"ERROR!"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>err.what()：what是runtime_error的一个成员函数，返回c风格字符串– 初始化一个具体对象所用的 string对象 的副本</p>
</li>
<li><p>函数在寻找处理代码的过程中退出</p>
<ul>
<li>抛出异常时，首先搜索抛出该异常的函数，如果没找到匹配的catch子句，终止该函数，在调用它的函数中继续寻找；若还没有找到catch，终止函数，继续在调用当前函数的函数中寻找。。。如此沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。</li>
<li>若最后也没找到catch子句，程序转到标准库函数terminate，执行该函数将导致程序非正常退出</li>
<li>对于没有try语句块定义的异常，处理方式一样。最终系统调用terminate函数并终止程序运行。</li>
</ul>
</li>
<li><p>编写 异常 安全（exception safe）的代码很困难</p>
<ul>
<li>异常中断了程序的正常流程</li>
<li>发生异常时，某些对象处理到一半就中止了，处于无效或未完成状态，资源没有正常释放</li>
<li>异常发生期间正确执行“清理”工作的程序代码即 异常 安全（exception safe）</li>
<li>异常发生后，<strong>程序如何确保对象有效</strong>、<strong>资源无泄漏</strong>、<strong>程序处于合理状态</strong>，十分关键</li>
</ul>
</li>
</ul>
</li>
<li><p>标准异常</p>
<ul>
<li>c++标准库定义的一组异常类，用于报告标准库函数遇到的问题</li>
<li>分别定义在4个头文件中：<ul>
<li>exception头文件：定义了最通用的异常类exception，只报告异常的发生，不提供额外信息</li>
<li>stdexcept头文件：定义了集中常用的异常类</li>
<li>new头文件：定义了bad_alloc异常类型</li>
<li>type_info头文件：定义了bad_cast异常类型</li>
</ul>
</li>
<li>只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，<strong>不允许赋初值</strong></li>
<li>其他异常行为需要使用string或C风格字符串初始化，<strong>不允许默认初始化</strong>，初始值含有错误相关的信息</li>
<li>异常类型只定义了一个成员函数what，该函数没有参数，返回一个指向C字符串的const char*，提供关于异常的文本信息。</li>
<li>what返回的字符串内容与异常对象的类型有关，若有字符串初始值则返回，否则由编译器决定</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>复合语句：即块</li>
<li>悬垂else</li>
<li>异常声明：catch子句中的声明</li>
<li>异常安全：抛出异常后，程序能执行正确的行为</li>
<li>控制流：程序的执行路径</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++_primer_V5 学习笔记-第八章</title>
    <url>/2020/08/04/c-primer-8/</url>
    <content><![CDATA[<h3 id="第II部分-C-标准库（第8章-第12章）"><a href="#第II部分-C-标准库（第8章-第12章）" class="headerlink" title="第II部分 C++标准库（第8章-第12章）"></a>第II部分 C++标准库（第8章-第12章）</h3><h3 id="第8章-IO库"><a href="#第8章-IO库" class="headerlink" title="第8章 IO库"></a>第8章 IO库</h3><p>本章介绍IO库的基本内容。</p>
<p>C语言通过一组定义在标准库中的类型来处理IO。IO库定义了读写内置类型值的操作。一些类也会定义类似的操作，来读写自己的对象。</p>
<a id="more"></a>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章更新较慢</title>
    <url>/2020/06/28/hexo%E6%96%87%E7%AB%A0%E6%9B%B4%E6%96%B0%E8%BE%83%E6%85%A2/</url>
    <content><![CDATA[<p>hexo的相关设置发布到github上生效慢，是chrome的浏览器缓存问题</p>
<h4 id="解决方法：ctrl-f5刷新chrome页面缓存"><a href="#解决方法：ctrl-f5刷新chrome页面缓存" class="headerlink" title="解决方法：ctrl+f5刷新chrome页面缓存"></a>解决方法：ctrl+f5刷新chrome页面缓存</h4>]]></content>
  </entry>
</search>
