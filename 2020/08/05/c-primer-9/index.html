<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/header32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/header16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第9章 顺序容器本章是第3章内容的扩展，进一步介绍了标准库的顺序容器。 除了顺序容器，标准库还定义了几种关联容器，将在第11章中介绍。 所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。公共接口使容器的学习更加容易——基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++_primer_V5 学习笔记-第九章">
<meta property="og:url" content="http://yoursite.com/2020/08/05/c-primer-9/index.html">
<meta property="og:site_name" content="Dawn&#39;s Blog">
<meta property="og:description" content="第9章 顺序容器本章是第3章内容的扩展，进一步介绍了标准库的顺序容器。 除了顺序容器，标准库还定义了几种关联容器，将在第11章中介绍。 所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。公共接口使容器的学习更加容易——基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-05T09:11:57.000Z">
<meta property="article:modified_time" content="2020-08-10T02:56:36.573Z">
<meta property="article:author" content="Dawn">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/08/05/c-primer-9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++_primer_V5 学习笔记-第九章 | Dawn's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dawn's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Something Written.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/c-primer-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon1.jpg">
      <meta itemprop="name" content="Dawn">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dawn's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++_primer_V5 学习笔记-第九章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-05 17:11:57" itemprop="dateCreated datePublished" datetime="2020-08-05T17:11:57+08:00">2020-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-10 10:56:36" itemprop="dateModified" datetime="2020-08-10T10:56:36+08:00">2020-08-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="第9章-顺序容器"><a href="#第9章-顺序容器" class="headerlink" title="第9章 顺序容器"></a>第9章 顺序容器</h3><p>本章是第3章内容的扩展，进一步介绍了标准库的顺序容器。</p>
<p>除了顺序容器，标准库还定义了几种关联容器，将在第11章中介绍。</p>
<p>所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。公共接口使容器的学习更加容易——基于某种容器所学习的内容也都适用于其他容器。每种容器都提供了不同的性能和功能的权衡。</p>
<a id="more"></a>

<p>一个容器就是一些特定类型对象的集合。</p>
<p>顺序容器为程序员提供了控制元素存储和访问顺序的能力，这种顺序与元素加入容器时的位置对应。</p>
<p>标准库还提供了三种容器适配器，分别为容器操作定义了不同的接口，来与容器类型适配。</p>
<h4 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h4><ul>
<li>在以下方面有不同的性能折中:<ul>
<li>想容器添加或从容器中删除元素的代价</li>
<li>非顺序访问容器中元素的代价</li>
</ul>
</li>
<li>顺序容器类型：vector deque list forward_list array string</li>
<li>除array外高效灵活的内存管理</li>
<li>forward_list没有size操作，减少开销；对其他容器而言，size保证是一个快速的常量时间的操作</li>
<li>新标准库的容器壁旧版本快得多，现代c++程序应该使用标准库容器</li>
<li>确定使用哪种顺序容器<ul>
<li>通常用vector</li>
<li>有很多小元素，空间额外开销很重要，使用list或forwardlist</li>
<li>随机访问元素 用vector或deque</li>
<li>在容器 中间插入或删除元素 用list或forwardlist</li>
<li>头尾插入或删除元素 不在中间位置插入 用deque</li>
<li>应用中站主导地位的操作决定了容器类型的选择</li>
<li>不确定用哪种，就只用vector和list的公共操作：迭代器，必要时再选择vector还是list</li>
</ul>
</li>
</ul>
<h4 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h4><ul>
<li><p>容器类型的操作层次</p>
<ul>
<li>所有容器类型都提供</li>
<li>仅针对顺序容器、关联容器或无序容器</li>
<li>只适用于一小部分容器</li>
</ul>
</li>
<li><p>接下来介绍仅适用于顺序容器的操作</p>
</li>
<li><p>每个容器定义在一个头文件中，容器名与类型名相同，对大多数容器，还要提供元素类型信息</p>
</li>
<li><p>对容器可以保存的元素类型的限制</p>
<ul>
<li>一个容器的元素类型可以是另一个容器</li>
<li>对于没有默认构造函数的类型，需要额外在形参里提供元素初始化器</li>
</ul>
</li>
<li><p>迭代器</p>
<ul>
<li>有公共的接口</li>
<li>forwardlist迭代器不支持递减运算符（–）</li>
<li>迭代器的算术运算 只应用于string vector deque array的迭代器</li>
<li>迭代器范围<ul>
<li>迭代器范围的概念是标准库的基础</li>
<li>一个迭代器范围有一堆迭代器表示，第二个迭代器指向尾元素之后的位置</li>
<li>迭代器范围中的元素是左闭合区间</li>
<li>满足如下条件，begin和end构成迭代器范围<ul>
<li>指向同一个容器中的元素或尾元素后的位置</li>
<li>end不在begin之前 可反复递增begin来到达end</li>
</ul>
</li>
</ul>
</li>
<li>使用左闭合范围蕴含的编程假定</li>
</ul>
</li>
<li><p>容器类型成员</p>
<ul>
<li>反向迭代器：反向遍历容器的迭代器</li>
<li>类型别名：value_type reference const_reference</li>
</ul>
</li>
<li><p>begin和end成员</p>
<ul>
<li>（begin和end成员）    —-常用与形成一个包含容器中所有元素的迭代器范围</li>
<li>可以将一个非常量迭代器转换为对应的常量迭代器，反过来不行</li>
<li>将auto与begin或end结合：获得的迭代器类型依赖于容器类型</li>
<li>当不需要写访问时，应使用cbegin和cend</li>
</ul>
</li>
<li><p>容器定义和初始化</p>
<ul>
<li>每个容器类型都有一个默认构造函数</li>
<li>除了array外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数</li>
<li>将一个容器初始化为另一个容器的拷贝<ul>
<li>直接拷贝整个容器：两个容器的类型与元素类型必须匹配</li>
<li>拷贝 迭代器对 指定的 元素范围：不要求容器类型相同，元素类型若能转换也可以不同</li>
</ul>
</li>
<li>列表初始化<ul>
<li>可以对容器列表初始化，也隐式指定了容器的大小</li>
</ul>
</li>
<li>与顺序容器大小相关的构造函数<ul>
<li>接收一个容器大小和一个（可选的）元素初始值</li>
<li>若元素类型没有默认构造函数，必须制定一个显式的元素初始值</li>
<li>顺序容器的构造函数才接受大小参数，关联容器不支持</li>
</ul>
</li>
<li>标准库array具有固定大小<ul>
<li>定义时要同时指定元素类型和容器大小</li>
<li>一个默认构造的array是非空的，包含与大小一致的元素，元素被默认初始化，剩余元素被值初始化</li>
<li>可以对array进行拷贝或对象赋值操作（内置数组类型不可），赋值两边的对象具有相同类型</li>
</ul>
</li>
</ul>
</li>
<li><p>赋值和swap</p>
<ul>
<li>array类型不支持assign，也不允许用花括号包围的值列表进行赋值</li>
<li>使用assign<ul>
<li>顺序容器除了array之外，定义了assign的成员</li>
<li>从一个不同但相容的类型赋值，或从容器的一个子序列赋值</li>
<li>用参数指定的元素的拷贝 替换 左边容器中的所有元素</li>
<li>由于旧元素被替换，传递给assign的迭代器不能指向调用assign的容器</li>
<li>第二个版本接收一个整型值和一个元素值，用指定数目且具有相同给定值的元素替换容器中原有的元素</li>
</ul>
</li>
<li>使用swap<ul>
<li>交换两个相同类型容器的内容，元素本身并未交换，交换了两个容器的内部数据结构</li>
<li>除array外，swap不对任何元素进行拷贝、删除或插入操作，可以保证在常数时间完成</li>
<li>除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效，仍指向操作前指向的元素</li>
<li>swap两个array会真正交换他们的元素，时间与元素数目成正比</li>
<li>统一使用非成员版本的swap</li>
</ul>
</li>
</ul>
</li>
<li><p>容器大小操作</p>
<ul>
<li>size：返回容器中元素数目</li>
<li>empty：size为0时返回布尔值true，否则返回false</li>
<li>max_size：返回一个大于或等于该类型容器所能容纳的 最大元素数 的值</li>
<li>forward_list不支持size</li>
</ul>
</li>
<li><p>关系运算符</p>
<ul>
<li>左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素</li>
<li>进行元素逐对比较<ul>
<li>相同大小 元素相等</li>
<li>不同大小，元素相等</li>
<li>不同大小 元素不相等，取决于第一个不相等的元素的比较结果</li>
</ul>
</li>
<li>容器的关系运算符使用元素的关系运算符完成比较<ul>
<li>只有当元素类型定义了相应的比较运算符时，才可以使用关系运算符来比较两个容器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h4><ul>
<li><p>介绍顺序容器特有的操作</p>
</li>
<li><p>向顺序容器添加元素</p>
<ul>
<li>除array外，都可以动态添加或删除元素来改变容器大小</li>
<li>向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效</li>
<li>使用push_back<ul>
<li>将一个元素追加到一个vector的尾部</li>
<li>除了array和forward_list之外的顺序容器都支持</li>
<li>用一个对象初始化容器，或将一个对象插入到容器中时，实际上放入的是对象值的一个拷贝，而非对象本身；容器中的元素与提供值的对象之间没有任何关联</li>
</ul>
</li>
<li>使用push_front<ul>
<li>list、forward_list和deque支持</li>
<li>将元素插入到容器头部</li>
</ul>
</li>
<li>在容器中的特定位置添加元素<ul>
<li>insert：在容器中任意位置插入0个或多个元素</li>
<li>接受一个迭代器作为第一个参数，将元素插入到迭代器所指定的位置之前</li>
<li>可以将元素插入到容器的开始位置，不必担心容器是否支持push_front</li>
<li>元素插入vector deque string 的任何位置都是合法的，但可能很耗时</li>
</ul>
</li>
<li>插入范围内元素<ul>
<li>insert接收一个元素和一个值，将指定数量的元素添加到指定位置之前，按给定值初始化</li>
<li>接收一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前，注意迭代器不能指向添加元素的目标容器</li>
<li>接收元素个数或范围的insert版本返回 指向第一个新加入元素的迭代器</li>
</ul>
</li>
<li>使用insert的返回值</li>
<li>使用emplace操作<ul>
<li>构造而非拷贝元素</li>
<li>调用emplace成员函数时，将参数传递给元素类型的构造函数；使用这些参数在容器管理的内存空间中直接构造元素</li>
<li>而调用push_back会创建一个局部临时对象，并将其压入容器中</li>
<li>emplace函数的参数必须与元素类型的构造函数相匹配</li>
</ul>
</li>
</ul>
</li>
<li><p>访问元素</p>
<ul>
<li>front和back分别返回首元素和尾元素的引用</li>
<li>获取首元素和尾元素的引用：调用front和back或解引用begin和end（先递减）返回的迭代器</li>
<li>调用front和back之前，要确保容器非空</li>
<li>访问成员函数返回的是引用</li>
<li>下标操作和安全的随机访问<ul>
<li>使用at成员函数确保下标合法</li>
</ul>
</li>
</ul>
</li>
<li><p>删除元素</p>
<ul>
<li>删除deque中除首尾外的任何元素都会使所有迭代器、引用和指针失效</li>
<li>指向vector或string中删除点之后位置的迭代器、引用和指针都会失效</li>
<li>删除元素的成员函数并不检查其参数，删除之前需要确保元素存在</li>
<li>pop_front和pop_back成员函数<ul>
<li>分别删除首元素和尾元素，返回void，需要弹出元素的值就要预先保存</li>
</ul>
</li>
<li>从容器内部删除一个元素<ul>
<li>erase从容器中指定位置删除元素</li>
<li>可以删除迭代器指定的单个元素，或一对迭代器指定的范围内所有元素</li>
<li>返回 指向删除的元素之后位置的迭代器</li>
</ul>
</li>
<li>删除多个元素<ul>
<li>若要删除一个容器中的所有元素，可以调用clear，也可以用begin和end调用erase</li>
</ul>
</li>
</ul>
</li>
<li><p>特殊的forward_list操作</p>
<ul>
<li>在forward_list中，添加或删除元素的操作是通过改变给定元素之后的元素来完成的</li>
<li>定义了before_begin，返回一个首前迭代器，使我们可以在链表首元素之前添加或删除元素</li>
</ul>
</li>
<li><p>改变容器大小</p>
</li>
<li><p>使用resize增大或缩小容器，array不支持</p>
<ul>
<li>当前大小大于所要求的大小，容器后部的元素会删除；若当前大小小于新大小，将新元素添加到容器后部</li>
</ul>
</li>
<li><p>resize接收一个可选的元素值参数，初始化添加到容器中的元素；若未提供此参数，新元素进行值初始化</p>
<ul>
<li>若容器保存类类型的元素，且resize向容器添加新元素，则必须提供初始值，或元素类型必须提供一个默认构造函数</li>
</ul>
</li>
<li><p>容器操作可能使迭代器生效</p>
<ul>
<li>向容器中添加或删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效</li>
<li>添加元素后：<ul>
<li>vector或string，存储空间重新分配，则指向容器的迭代器、指针和引用都会失效；若未重新分配，指向插入位置之后元素的迭代器、指针和引用将会失效</li>
<li>deque，插入到除首尾位置之外的任何位置都会使迭代器、指针、引用失效；若在首尾添加元素，只有迭代器会失效</li>
<li>list和forward_list，指向容器的迭代器 指针和引用仍有效</li>
</ul>
</li>
<li>删除元素后：指向被身处元素的迭代器 指针和引用会失效<ul>
<li>list和forward_list，指向其他位置的迭代器 应用和指针仍有效</li>
<li>deque，在首尾之外的任何位置删除元素 指向被删除元素外其他元素的迭代器 引用或指针也会失效；删除尾元素 尾后迭代器也会失效；删除首元素 这些都不受影响</li>
<li>vector和string，指向被删元素之前元素的迭代器 引用和指针仍有效</li>
<li>当我们删除元素时，尾后迭代器总是会失效</li>
</ul>
</li>
<li>必须保证每次改变容器的操作之后都正确地重新定位迭代器</li>
<li>编写改变容器的循环程序<ul>
<li>insert在给定位置之前插入新元素，然后返回指向新插入元素的迭代器</li>
</ul>
</li>
<li>不要保存end返回的迭代器<ul>
<li>如果在一个循环中插入/删除deque string 或vector中的元素，不要缓存end返回的迭代器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h4><ul>
<li>vector将元素连续存储，支持快速随机访问；获取新内存空间时，vector和string会分配比新的空间需求更大的内存空间</li>
<li>管理容量的成员函数</li>
<li>capacity操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素<ul>
<li>reverse：通知容器应该准备保存多少个元素，只影响vector预先分配多大的内存空间</li>
<li>需要的内存空间超过当前容量时，reserve调用才会改变vector的容量；否则reverse什么也不做<ul>
<li>永远不会减少容器占用的内存空间</li>
</ul>
</li>
</ul>
</li>
<li>resize：只改变容器中元素数目，而不是容器的容量</li>
<li>capacity和size</li>
<li>size：已经保存的元素的数目<ul>
<li>capacity：在不分配新内存空间的前提下它最多可以保存多少元素</li>
</ul>
</li>
<li>每个vector实现都可以选择自己的内存分配策略。但只有当迫不得已时才可以分配新的内存空间<ul>
<li>确保用push_back想vector添加元素的操作有高效率</li>
</ul>
</li>
</ul>
<h4 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h4><ul>
<li>构造string的其他方法    <ul>
<li>若我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的</li>
<li>从string拷贝字符时，可以提供一个可选的开始位置和一个计数值。开始位置必须小于或等于给定的string的大小。否则构造函数抛出一个out_of_range异常。</li>
<li>substr操作<ul>
<li>返回一个string，是原始string的一部分或全部的拷贝</li>
<li>可以传递给substr一个可选的开始位置和计数值</li>
<li>若开始位置加上计数值大于string的大小，substr只拷贝到string的末尾</li>
</ul>
</li>
</ul>
</li>
<li>改变string的其他方法<ul>
<li>接收下标的版本，指出了开始删除的位置，或是insert到给定值之前的位置</li>
<li>接收C风格字符数据的insert和assign版本</li>
<li>append和replace函数<ul>
<li>append 在string末尾进行插入操作的一种简写形式</li>
<li>replace 调用erase和insert的一种简写形式</li>
</ul>
</li>
<li>改变string的多种重载函数<ul>
<li>append assign insert replace函数有多个重载版本，这些函数有共同的接口</li>
</ul>
</li>
</ul>
</li>
<li>string搜索操作<ul>
<li>每个搜索操作返回一个string::size_type值(unsigned类型），表示匹配发生位置的下标。若搜索失败，则返回一个名为string::npos的static成员。</li>
<li>find函数完成最简单的搜索</li>
<li>指定在哪里开始搜索<ul>
<li>可以传递给find操作一个可选的开始位置，指出从哪个位置开始搜索</li>
</ul>
</li>
<li>逆向搜索<ul>
<li>由右至左搜索 比如rfind</li>
</ul>
</li>
</ul>
</li>
<li>compare函数<ul>
<li>根据字符串s是等于、大于还是小于参数指定的字符串，返回0、正数或负数</li>
<li>有6个版本</li>
</ul>
</li>
<li>数值转换<ul>
<li>数值数据与标准库string之间的转换</li>
<li>若string不能转换为一个数值，这些函数抛出一个invalid_argument异常；若转换得到的数值无法用任何类型来表示，则抛出一个out_of_range异常</li>
</ul>
</li>
</ul>
<h4 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h4><ul>
<li>适配器是标准库中的一个通用概念</li>
<li>一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样</li>
<li>一个容器适配器接收一种已有的 容器类型，使其行为看起来像一种不同的类型</li>
<li>标准库定义了三个顺序容器适配器 stack queue priority_queue</li>
<li>定义一个适配器<ul>
<li>每个适配器定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器<ul>
<li>可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型</li>
</ul>
</li>
<li>所有适配器都要求容器具有添加删除元素的能力，因此适配器不能构造在array上，也不能用forward_list构造适配器</li>
</ul>
</li>
<li>栈适配器<ul>
<li>stack类型定义在stack头文件中</li>
<li>每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层容器类型的操作。</li>
</ul>
</li>
<li>队列适配器<ul>
<li>queue和priority_queue定义在queue头文件中</li>
<li>queue使用先进先出FIFO的存储和访问策略</li>
<li>priority_queue允许为队列中的元素建立优先级，新加入的元素排在所有优先级比它低的已有元素之前。</li>
<li>默认情况下，标准库在元素类型上使用&lt;运算符来确定相对优先级，将在第12章学习如何重载默认设置</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>顺序容器有公共的标准接口：若两个顺序容器都提供一个特定的操作，那么这个操作在两个容器中具有相同的接口和含义</li>
<li>所有容器（除array）提供高效的动态内存管理。</li>
<li>容器只定义了极少的操作。每个容器定义了构造函数、添加删除元素、确定容器大小、返回指向特定元素的迭代器等操作；其他的操作由标准库算法实现，在第10章介绍</li>
<li>使用添加删除元素的容器操作时，注意这些操作可能使指向容器中元素的迭代器、指针或引用失效，需要尤其注意。</li>
</ul>
<h4 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h4><ul>
<li>适配器</li>
<li>容器</li>
<li>迭代器范围</li>
<li>首前迭代器</li>
<li>尾后迭代器</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/04/c-primer-8/" rel="prev" title="C++_primer_V5 学习笔记-第八章">
      <i class="fa fa-chevron-left"></i> C++_primer_V5 学习笔记-第八章
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#第9章-顺序容器"><span class="nav-number">1.</span> <span class="nav-text">第9章 顺序容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序容器概述"><span class="nav-number">1.1.</span> <span class="nav-text">顺序容器概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器库概览"><span class="nav-number">1.2.</span> <span class="nav-text">容器库概览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序容器操作"><span class="nav-number">1.3.</span> <span class="nav-text">顺序容器操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector对象是如何增长的"><span class="nav-number">1.4.</span> <span class="nav-text">vector对象是如何增长的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#额外的string操作"><span class="nav-number">1.5.</span> <span class="nav-text">额外的string操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器适配器"><span class="nav-number">1.6.</span> <span class="nav-text">容器适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">1.7.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#术语表"><span class="nav-number">1.8.</span> <span class="nav-text">术语表</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dawn"
      src="/images/icon1.jpg">
  <p class="site-author-name" itemprop="name">Dawn</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dawn-0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dawn-0" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.google.com/" title="Google → https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/" title="YouTube → https:&#x2F;&#x2F;youtube.com" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.baidu.com/" title="http:&#x2F;&#x2F;www.baidu.com" rel="noopener" target="_blank">Baidu</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.douban.com/" title="http:&#x2F;&#x2F;www.douban.com" rel="noopener" target="_blank">Douban</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dawn</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
